


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > InstrumentedEE10Handler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.dropwizard.metrics.jetty12.ee10</a>
</div>

<h1>Coverage Summary for Class: InstrumentedEE10Handler (io.dropwizard.metrics.jetty12.ee10)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InstrumentedEE10Handler</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.9%
  </span>
  <span class="absValue">
    (23/32)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InstrumentedEE10Handler$1</td>
  </tr>
  <tr>
    <td class="name">InstrumentedEE10Handler$AsyncAttachingListener</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedEE10Handler$InstrumentedAsyncListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    29.4%
  </span>
  <span class="absValue">
    (5/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48%
  </span>
  <span class="absValue">
    (24/50)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package io.dropwizard.metrics.jetty12.ee10;
&nbsp;
&nbsp;import com.codahale.metrics.MetricRegistry;
&nbsp;import com.codahale.metrics.annotation.ResponseMeteredLevel;
&nbsp;import io.dropwizard.metrics.jetty12.AbstractInstrumentedHandler;
&nbsp;import jakarta.servlet.AsyncEvent;
&nbsp;import jakarta.servlet.AsyncListener;
&nbsp;import org.eclipse.jetty.ee10.servlet.AsyncContextState;
&nbsp;import org.eclipse.jetty.ee10.servlet.ServletApiRequest;
&nbsp;import org.eclipse.jetty.ee10.servlet.ServletApiResponse;
&nbsp;import org.eclipse.jetty.ee10.servlet.ServletChannelState;
&nbsp;import org.eclipse.jetty.ee10.servlet.ServletContextRequest;
&nbsp;import org.eclipse.jetty.server.Handler;
&nbsp;import org.eclipse.jetty.server.Request;
&nbsp;import org.eclipse.jetty.server.Response;
&nbsp;import org.eclipse.jetty.util.Callback;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import static com.codahale.metrics.annotation.ResponseMeteredLevel.COARSE;
&nbsp;
&nbsp;/**
&nbsp; * A Jetty {@link Handler} which records various metrics about an underlying {@link Handler}
&nbsp; * instance. This {@link Handler} requires a {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler} to be present.
&nbsp; * For correct behaviour, the {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler} should be before this handler
&nbsp; * in the handler chain. To achieve this, one can use
&nbsp; * {@link org.eclipse.jetty.ee10.servlet.ServletContextHandler#insertHandler(Singleton)}.
&nbsp; */
<b class="nc">&nbsp;public class InstrumentedEE10Handler extends AbstractInstrumentedHandler {</b>
&nbsp;    private AsyncListener listener;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instrumented handler using a given metrics registry.
&nbsp;     *
&nbsp;     * @param registry the registry for the metrics
&nbsp;     */
&nbsp;    public InstrumentedEE10Handler(MetricRegistry registry) {
<b class="nc">&nbsp;        super(registry, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instrumented handler using a given metrics registry.
&nbsp;     *
&nbsp;     * @param registry the registry for the metrics
&nbsp;     * @param prefix   the prefix to use for the metrics names
&nbsp;     */
&nbsp;    public InstrumentedEE10Handler(MetricRegistry registry, String prefix) {
<b class="nc">&nbsp;        super(registry, prefix, COARSE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a new instrumented handler using a given metrics registry.
&nbsp;     *
&nbsp;     * @param registry the registry for the metrics
&nbsp;     * @param prefix   the prefix to use for the metrics names
&nbsp;     * @param responseMeteredLevel the level to determine individual/aggregate response codes that are instrumented
&nbsp;     */
&nbsp;    public InstrumentedEE10Handler(MetricRegistry registry, String prefix, ResponseMeteredLevel responseMeteredLevel) {
<b class="fc">&nbsp;        super(registry, prefix, responseMeteredLevel);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void doStart() throws Exception {
<b class="fc">&nbsp;        super.doStart();</b>
&nbsp;
<b class="fc">&nbsp;        this.listener = new AsyncAttachingListener();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void doStop() throws Exception {
<b class="fc">&nbsp;        super.doStop();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean handle(Request request, Response response, Callback callback) throws Exception {
<b class="fc">&nbsp;        ServletContextRequest servletContextRequest = Request.as(request, ServletContextRequest.class);</b>
&nbsp;
&nbsp;        // only handle servlet requests with the InstrumentedHandler
&nbsp;        // because it depends on the ServletRequestState
<b class="fc">&nbsp;        if (servletContextRequest == null) {</b>
<b class="nc">&nbsp;            return super.handle(request, response, callback);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        activeDispatches.inc();</b>
&nbsp;
&nbsp;        final long start;
<b class="fc">&nbsp;        final ServletChannelState state = servletContextRequest.getServletRequestState();</b>
<b class="fc">&nbsp;        if (state.isInitial()) {</b>
&nbsp;            // new request
<b class="fc">&nbsp;            activeRequests.inc();</b>
<b class="fc">&nbsp;            start = Request.getTimeStamp(request);</b>
<b class="fc">&nbsp;            state.addListener(listener);</b>
&nbsp;        } else {
&nbsp;            // resumed request
<b class="nc">&nbsp;            start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            activeSuspended.dec();</b>
<b class="nc">&nbsp;            if (state.getState() == ServletChannelState.State.HANDLING) {</b>
<b class="nc">&nbsp;                asyncDispatches.mark();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        boolean handled = false;</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            handled = super.handle(request, response, callback);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            final long now = System.currentTimeMillis();</b>
<b class="fc">&nbsp;            final long dispatched = now - start;</b>
&nbsp;
<b class="fc">&nbsp;            activeDispatches.dec();</b>
<b class="fc">&nbsp;            dispatches.update(dispatched, TimeUnit.MILLISECONDS);</b>
&nbsp;
<b class="fc">&nbsp;            if (state.isSuspended()) {</b>
<b class="nc">&nbsp;                activeSuspended.inc();</b>
<b class="fc">&nbsp;            } else if (state.isInitial()) {</b>
<b class="fc">&nbsp;                updateResponses(request, response, start, handled);</b>
&nbsp;            }
&nbsp;            // else onCompletion will handle it.
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return handled;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private class AsyncAttachingListener implements AsyncListener {</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public void onTimeout(AsyncEvent event) throws IOException {}</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onStartAsync(AsyncEvent event) throws IOException {
<b class="nc">&nbsp;            event.getAsyncContext().addListener(new InstrumentedAsyncListener());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public void onError(AsyncEvent event) throws IOException {}</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public void onComplete(AsyncEvent event) throws IOException {}</b>
&nbsp;    }
&nbsp;
&nbsp;    private class InstrumentedAsyncListener implements AsyncListener {
&nbsp;        private final long startTime;
&nbsp;
<b class="nc">&nbsp;        InstrumentedAsyncListener() {</b>
<b class="nc">&nbsp;            this.startTime = System.currentTimeMillis();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onTimeout(AsyncEvent event) throws IOException {
<b class="nc">&nbsp;            asyncTimeouts.mark();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onStartAsync(AsyncEvent event) throws IOException {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(AsyncEvent event) throws IOException {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onComplete(AsyncEvent event) throws IOException {
<b class="nc">&nbsp;            final AsyncContextState state = (AsyncContextState) event.getAsyncContext();</b>
<b class="nc">&nbsp;            final ServletApiRequest request = (ServletApiRequest) state.getRequest();</b>
<b class="nc">&nbsp;            final ServletApiResponse response = (ServletApiResponse) state.getResponse();</b>
<b class="nc">&nbsp;            updateResponses(request.getRequest(), response.getResponse(), startTime, true);</b>
&nbsp;
<b class="nc">&nbsp;            final ServletContextRequest servletContextRequest = Request.as(request.getRequest(), ServletContextRequest.class);</b>
<b class="nc">&nbsp;            final ServletChannelState servletRequestState = servletContextRequest.getServletRequestState();</b>
<b class="nc">&nbsp;            if (!servletRequestState.isSuspended()) {</b>
<b class="nc">&nbsp;                activeSuspended.dec();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-29 23:40</div>
</div>
</body>
</html>
