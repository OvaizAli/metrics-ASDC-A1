


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > HealthCheckRegistry</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.codahale.metrics.health</a>
</div>

<h1>Coverage Summary for Class: HealthCheckRegistry (com.codahale.metrics.health)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HealthCheckRegistry</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (18/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (70/78)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HealthCheckRegistry$NamedThreadFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (20/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.8%
  </span>
  <span class="absValue">
    (79/88)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.codahale.metrics.health;
&nbsp;
&nbsp;import com.codahale.metrics.health.annotation.Async;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.SortedSet;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.ScheduledThreadPoolExecutor;
&nbsp;import java.util.concurrent.ThreadFactory;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;
&nbsp;import static com.codahale.metrics.health.HealthCheck.Result;
&nbsp;
&nbsp;/**
&nbsp; * A registry for health checks.
&nbsp; */
&nbsp;public class HealthCheckRegistry {
<b class="fc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(HealthCheckRegistry.class);</b>
&nbsp;    private static final int ASYNC_EXECUTOR_POOL_SIZE = 2;
&nbsp;
&nbsp;    private final ConcurrentMap&lt;String, HealthCheck&gt; healthChecks;
&nbsp;    private final List&lt;HealthCheckRegistryListener&gt; listeners;
&nbsp;    private final ScheduledExecutorService asyncExecutorService;
<b class="fc">&nbsp;    private final Object lock = new Object();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link HealthCheckRegistry}.
&nbsp;     */
&nbsp;    public HealthCheckRegistry() {
<b class="fc">&nbsp;        this(ASYNC_EXECUTOR_POOL_SIZE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link HealthCheckRegistry}.
&nbsp;     *
&nbsp;     * @param asyncExecutorPoolSize core pool size for async health check executions
&nbsp;     */
&nbsp;    public HealthCheckRegistry(int asyncExecutorPoolSize) {
<b class="fc">&nbsp;        this(createExecutorService(asyncExecutorPoolSize));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link HealthCheckRegistry}.
&nbsp;     *
&nbsp;     * @param asyncExecutorService executor service for async health check executions
&nbsp;     */
<b class="fc">&nbsp;    public HealthCheckRegistry(ScheduledExecutorService asyncExecutorService) {</b>
<b class="fc">&nbsp;        this.healthChecks = new ConcurrentHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.listeners = new CopyOnWriteArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        this.asyncExecutorService = asyncExecutorService;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
&nbsp;     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
&nbsp;     * existing health checks when it first registers.
&nbsp;     *
&nbsp;     * @param listener listener to add
&nbsp;     */
&nbsp;    public void addListener(HealthCheckRegistryListener listener) {
<b class="fc">&nbsp;        listeners.add(listener);</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, HealthCheck&gt; entry : healthChecks.entrySet()) {</b>
<b class="fc">&nbsp;            listener.onHealthCheckAdded(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes a {@link HealthCheckRegistryListener} from this registry&#39;s collection of listeners.
&nbsp;     *
&nbsp;     * @param listener listener to remove
&nbsp;     */
&nbsp;    public void removeListener(HealthCheckRegistryListener listener) {
<b class="fc">&nbsp;        listeners.remove(listener);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers an application {@link HealthCheck}.
&nbsp;     *
&nbsp;     * @param name        the name of the health check
&nbsp;     * @param healthCheck the {@link HealthCheck} instance
&nbsp;     */
&nbsp;    public void register(String name, HealthCheck healthCheck) {
&nbsp;        HealthCheck registered;
<b class="fc">&nbsp;        synchronized (lock) {</b>
<b class="fc">&nbsp;            if (healthChecks.containsKey(name)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;A health check named &quot; + name + &quot; already exists&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            registered = healthCheck;</b>
<b class="fc">&nbsp;            if (healthCheck.getClass().isAnnotationPresent(Async.class)) {</b>
<b class="fc">&nbsp;                registered = new AsyncHealthCheckDecorator(healthCheck, asyncExecutorService);</b>
&nbsp;            }
<b class="fc">&nbsp;            healthChecks.put(name, registered);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        onHealthCheckAdded(name, registered);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Unregisters the application {@link HealthCheck} with the given name.
&nbsp;     *
&nbsp;     * @param name the name of the {@link HealthCheck} instance
&nbsp;     */
&nbsp;    public void unregister(String name) {
&nbsp;        HealthCheck healthCheck;
<b class="fc">&nbsp;        synchronized (lock) {</b>
<b class="fc">&nbsp;            healthCheck = healthChecks.remove(name);</b>
<b class="fc">&nbsp;            if (healthCheck instanceof AsyncHealthCheckDecorator) {</b>
<b class="fc">&nbsp;                ((AsyncHealthCheckDecorator) healthCheck).tearDown();</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (healthCheck != null) {</b>
<b class="fc">&nbsp;            onHealthCheckRemoved(name, healthCheck);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set of the names of all registered health checks.
&nbsp;     *
&nbsp;     * @return the names of all registered health checks
&nbsp;     */
&nbsp;    public SortedSet&lt;String&gt; getNames() {
<b class="fc">&nbsp;        return Collections.unmodifiableSortedSet(new TreeSet&lt;&gt;(healthChecks.keySet()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link HealthCheck} instance with a given name
&nbsp;     *
&nbsp;     * @param name the name of the {@link HealthCheck} instance
&nbsp;     */
&nbsp;    public HealthCheck getHealthCheck(String name) {
<b class="nc">&nbsp;        return healthChecks.get(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the health check with the given name.
&nbsp;     *
&nbsp;     * @param name the health check&#39;s name
&nbsp;     * @return the result of the health check
&nbsp;     * @throws NoSuchElementException if there is no health check with the given name
&nbsp;     */
&nbsp;    public HealthCheck.Result runHealthCheck(String name) throws NoSuchElementException {
<b class="fc">&nbsp;        final HealthCheck healthCheck = healthChecks.get(name);</b>
<b class="fc">&nbsp;        if (healthCheck == null) {</b>
<b class="fc">&nbsp;            throw new NoSuchElementException(&quot;No health check named &quot; + name + &quot; exists&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        return healthCheck.execute();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the registered health checks and returns a map of the results.
&nbsp;     *
&nbsp;     * @return a map of the health check results
&nbsp;     */
&nbsp;    public SortedMap&lt;String, HealthCheck.Result&gt; runHealthChecks() {
<b class="fc">&nbsp;        return runHealthChecks(HealthCheckFilter.ALL);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the registered health checks matching the filter and returns a map of the results.
&nbsp;     *
&nbsp;     * @param filter health check filter
&nbsp;     * @return a map of the health check results
&nbsp;     */
&nbsp;    public SortedMap&lt;String, HealthCheck.Result&gt; runHealthChecks(HealthCheckFilter filter) {
<b class="fc">&nbsp;        final SortedMap&lt;String, HealthCheck.Result&gt; results = new TreeMap&lt;&gt;();</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, HealthCheck&gt; entry : healthChecks.entrySet()) {</b>
<b class="fc">&nbsp;            final String name = entry.getKey();</b>
<b class="fc">&nbsp;            final HealthCheck healthCheck = entry.getValue();</b>
<b class="fc">&nbsp;            if (filter.matches(name, healthCheck)) {</b>
<b class="fc">&nbsp;                final Result result = entry.getValue().execute();</b>
<b class="fc">&nbsp;                results.put(entry.getKey(), result);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return Collections.unmodifiableSortedMap(results);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the registered health checks in parallel and returns a map of the results.
&nbsp;     *
&nbsp;     * @param executor object to launch and track health checks progress
&nbsp;     * @return a map of the health check results
&nbsp;     */
&nbsp;    public SortedMap&lt;String, HealthCheck.Result&gt; runHealthChecks(ExecutorService executor) {
<b class="fc">&nbsp;        return runHealthChecks(executor, HealthCheckFilter.ALL);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the registered health checks matching the filter in parallel and returns a map of the results.
&nbsp;     *
&nbsp;     * @param executor object to launch and track health checks progress
&nbsp;     * @param filter   health check filter
&nbsp;     * @return a map of the health check results
&nbsp;     */
&nbsp;    public SortedMap&lt;String, HealthCheck.Result&gt; runHealthChecks(ExecutorService executor, HealthCheckFilter filter) {
<b class="fc">&nbsp;        final Map&lt;String, Future&lt;HealthCheck.Result&gt;&gt; futures = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        for (final Map.Entry&lt;String, HealthCheck&gt; entry : healthChecks.entrySet()) {</b>
<b class="fc">&nbsp;            final String name = entry.getKey();</b>
<b class="fc">&nbsp;            final HealthCheck healthCheck = entry.getValue();</b>
<b class="fc">&nbsp;            if (filter.matches(name, healthCheck)) {</b>
<b class="fc">&nbsp;                futures.put(name, executor.submit(() -&gt; healthCheck.execute()));</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        final SortedMap&lt;String, HealthCheck.Result&gt; results = new TreeMap&lt;&gt;();</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, Future&lt;Result&gt;&gt; entry : futures.entrySet()) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                results.put(entry.getKey(), entry.getValue().get());</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.warn(&quot;Error executing health check {}&quot;, entry.getKey(), e);</b>
<b class="nc">&nbsp;                results.put(entry.getKey(), HealthCheck.Result.unhealthy(e));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return Collections.unmodifiableSortedMap(results);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private void onHealthCheckAdded(String name, HealthCheck healthCheck) {
<b class="fc">&nbsp;        for (HealthCheckRegistryListener listener : listeners) {</b>
<b class="fc">&nbsp;            listener.onHealthCheckAdded(name, healthCheck);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onHealthCheckRemoved(String name, HealthCheck healthCheck) {
<b class="fc">&nbsp;        for (HealthCheckRegistryListener listener : listeners) {</b>
<b class="fc">&nbsp;            listener.onHealthCheckRemoved(name, healthCheck);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shuts down the scheduled executor for async health checks
&nbsp;     */
&nbsp;    public void shutdown() {
<b class="fc">&nbsp;        asyncExecutorService.shutdown(); // Disable new health checks from being submitted</b>
&nbsp;        try {
&nbsp;            // Give some time to the current healtch checks to finish gracefully
<b class="fc">&nbsp;            if (!asyncExecutorService.awaitTermination(1, TimeUnit.SECONDS)) {</b>
<b class="nc">&nbsp;                asyncExecutorService.shutdownNow();</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (InterruptedException ie) {</b>
<b class="nc">&nbsp;            asyncExecutorService.shutdownNow();</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static ScheduledExecutorService createExecutorService(int corePoolSize) {
<b class="fc">&nbsp;        final ScheduledThreadPoolExecutor asyncExecutorService = new ScheduledThreadPoolExecutor(corePoolSize,</b>
&nbsp;                new NamedThreadFactory(&quot;healthcheck-async-executor-&quot;));
<b class="fc">&nbsp;        asyncExecutorService.setRemoveOnCancelPolicy(true);</b>
<b class="fc">&nbsp;        return asyncExecutorService;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class NamedThreadFactory implements ThreadFactory {
&nbsp;
&nbsp;        private final ThreadGroup group;
<b class="fc">&nbsp;        private final AtomicInteger threadNumber = new AtomicInteger(1);</b>
&nbsp;        private final String namePrefix;
&nbsp;
<b class="fc">&nbsp;        NamedThreadFactory(String namePrefix) {</b>
<b class="fc">&nbsp;            SecurityManager s = System.getSecurityManager();</b>
<b class="fc">&nbsp;            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</b>
<b class="fc">&nbsp;            this.namePrefix = namePrefix;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Thread newThread(Runnable r) {
<b class="fc">&nbsp;            Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);</b>
<b class="fc">&nbsp;            t.setDaemon(true);</b>
<b class="fc">&nbsp;            if (t.getPriority() != Thread.NORM_PRIORITY)</b>
<b class="nc">&nbsp;                t.setPriority(Thread.NORM_PRIORITY);</b>
<b class="fc">&nbsp;            return t;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-29 23:40</div>
</div>
</body>
</html>
