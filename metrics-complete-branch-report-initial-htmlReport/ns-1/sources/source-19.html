


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ScheduledReporter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.codahale.metrics</a>
</div>

<h1>Coverage Summary for Class: ScheduledReporter (com.codahale.metrics)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ScheduledReporter</td>
<td class="coverageStat">
  <span class="percent">
    91.3%
  </span>
  <span class="absValue">
    (21/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65.8%
  </span>
  <span class="absValue">
    (52/79)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ScheduledReporter$1</td>
  </tr>
  <tr>
    <td class="name">ScheduledReporter$NamedThreadFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (24/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.1%
  </span>
  <span class="absValue">
    (62/91)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.codahale.metrics;
&nbsp;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.concurrent.Executor;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.ThreadFactory;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;
&nbsp;/**
&nbsp; * The abstract base class for all scheduled reporters (i.e., reporters which process a registry&#39;s
&nbsp; * metrics periodically).
&nbsp; *
&nbsp; * @see ConsoleReporter
&nbsp; * @see CsvReporter
&nbsp; * @see Slf4jReporter
&nbsp; */
&nbsp;public abstract class ScheduledReporter implements Closeable, Reporter {
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOG = LoggerFactory.getLogger(ScheduledReporter.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A simple named thread factory.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;NullableProblems&quot;)
<b class="fc">&nbsp;    private static class NamedThreadFactory implements ThreadFactory {</b>
&nbsp;        private final ThreadGroup group;
<b class="fc">&nbsp;        private final AtomicInteger threadNumber = new AtomicInteger(1);</b>
&nbsp;        private final String namePrefix;
&nbsp;
<b class="fc">&nbsp;        private NamedThreadFactory(String name) {</b>
<b class="fc">&nbsp;            final SecurityManager s = System.getSecurityManager();</b>
<b class="pc">&nbsp;            this.group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</b>
<b class="fc">&nbsp;            this.namePrefix = &quot;metrics-&quot; + name + &quot;-thread-&quot;;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public Thread newThread(Runnable r) {
<b class="fc">&nbsp;            final Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);</b>
<b class="fc">&nbsp;            t.setDaemon(true);</b>
<b class="pc">&nbsp;            if (t.getPriority() != Thread.NORM_PRIORITY) {</b>
<b class="nc">&nbsp;                t.setPriority(Thread.NORM_PRIORITY);</b>
&nbsp;            }
<b class="fc">&nbsp;            return t;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final AtomicInteger FACTORY_ID = new AtomicInteger();</b>
&nbsp;
&nbsp;    private final MetricRegistry registry;
&nbsp;    private final ScheduledExecutorService executor;
&nbsp;    private final boolean shutdownExecutorOnStop;
&nbsp;    private final Set&lt;MetricAttribute&gt; disabledMetricAttributes;
&nbsp;    private ScheduledFuture&lt;?&gt; scheduledFuture;
&nbsp;    private final MetricFilter filter;
&nbsp;    private final long durationFactor;
&nbsp;    private final String durationUnit;
&nbsp;    private final long rateFactor;
&nbsp;    private final String rateUnit;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ScheduledReporter} instance.
&nbsp;     *
&nbsp;     * @param registry     the {@link com.codahale.metrics.MetricRegistry} containing the metrics this
&nbsp;     *                     reporter will report
&nbsp;     * @param name         the reporter&#39;s name
&nbsp;     * @param filter       the filter for which metrics to report
&nbsp;     * @param rateUnit     a unit of time
&nbsp;     * @param durationUnit a unit of time
&nbsp;     */
&nbsp;    protected ScheduledReporter(MetricRegistry registry,
&nbsp;                                String name,
&nbsp;                                MetricFilter filter,
&nbsp;                                TimeUnit rateUnit,
&nbsp;                                TimeUnit durationUnit) {
<b class="fc">&nbsp;        this(registry, name, filter, rateUnit, durationUnit, createDefaultExecutor(name));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ScheduledReporter} instance.
&nbsp;     *
&nbsp;     * @param registry the {@link com.codahale.metrics.MetricRegistry} containing the metrics this
&nbsp;     *                 reporter will report
&nbsp;     * @param name     the reporter&#39;s name
&nbsp;     * @param filter   the filter for which metrics to report
&nbsp;     * @param executor the executor to use while scheduling reporting of metrics.
&nbsp;     */
&nbsp;    protected ScheduledReporter(MetricRegistry registry,
&nbsp;                                String name,
&nbsp;                                MetricFilter filter,
&nbsp;                                TimeUnit rateUnit,
&nbsp;                                TimeUnit durationUnit,
&nbsp;                                ScheduledExecutorService executor) {
<b class="fc">&nbsp;        this(registry, name, filter, rateUnit, durationUnit, executor, true);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ScheduledReporter} instance.
&nbsp;     *
&nbsp;     * @param registry               the {@link com.codahale.metrics.MetricRegistry} containing the metrics this
&nbsp;     *                               reporter will report
&nbsp;     * @param name                   the reporter&#39;s name
&nbsp;     * @param filter                 the filter for which metrics to report
&nbsp;     * @param executor               the executor to use while scheduling reporting of metrics.
&nbsp;     * @param shutdownExecutorOnStop if true, then executor will be stopped in same time with this reporter
&nbsp;     */
&nbsp;    protected ScheduledReporter(MetricRegistry registry,
&nbsp;                                String name,
&nbsp;                                MetricFilter filter,
&nbsp;                                TimeUnit rateUnit,
&nbsp;                                TimeUnit durationUnit,
&nbsp;                                ScheduledExecutorService executor,
&nbsp;                                boolean shutdownExecutorOnStop) {
<b class="fc">&nbsp;        this(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop, Collections.emptySet());</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected ScheduledReporter(MetricRegistry registry,
&nbsp;                                String name,
&nbsp;                                MetricFilter filter,
&nbsp;                                TimeUnit rateUnit,
&nbsp;                                TimeUnit durationUnit,
&nbsp;                                ScheduledExecutorService executor,
&nbsp;                                boolean shutdownExecutorOnStop,
<b class="fc">&nbsp;                                Set&lt;MetricAttribute&gt; disabledMetricAttributes) {</b>
&nbsp;
<b class="pc">&nbsp;        if (registry == null) {</b>
<b class="fc">&nbsp;            throw new NullPointerException(&quot;registry == null&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.registry = registry;</b>
<b class="fc">&nbsp;        this.filter = filter;</b>
<b class="pc">&nbsp;        this.executor = executor == null ? createDefaultExecutor(name) : executor;</b>
<b class="fc">&nbsp;        this.shutdownExecutorOnStop = shutdownExecutorOnStop;</b>
<b class="fc">&nbsp;        this.rateFactor = rateUnit.toSeconds(1);</b>
<b class="fc">&nbsp;        this.rateUnit = calculateRateUnit(rateUnit);</b>
<b class="fc">&nbsp;        this.durationFactor = durationUnit.toNanos(1);</b>
<b class="fc">&nbsp;        this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);</b>
<b class="pc">&nbsp;        this.disabledMetricAttributes = disabledMetricAttributes != null ? disabledMetricAttributes :</b>
<b class="fc">&nbsp;                Collections.emptySet();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Starts the reporter polling at the given period.
&nbsp;     *
&nbsp;     * @param period the amount of time between polls
&nbsp;     * @param unit   the unit for {@code period}
&nbsp;     */
&nbsp;    public void start(long period, TimeUnit unit) {
<b class="fc">&nbsp;        start(period, period, unit);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Starts the reporter polling at the given period with the specific runnable action.
&nbsp;     * Visible only for testing.
&nbsp;     */
&nbsp;    synchronized void start(long initialDelay, long period, TimeUnit unit, Runnable runnable) {
<b class="pc">&nbsp;        if (this.scheduledFuture != null) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Reporter already started&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.scheduledFuture = getScheduledFuture(initialDelay, period, unit, runnable);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Schedule the task, and return a future.
&nbsp;     *
&nbsp;     * @deprecated Use {@link #getScheduledFuture(long, long, TimeUnit, Runnable, ScheduledExecutorService)} instead.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;DeprecatedIsStillUsed&quot;)
&nbsp;    @Deprecated
&nbsp;    protected ScheduledFuture&lt;?&gt; getScheduledFuture(long initialDelay, long period, TimeUnit unit, Runnable runnable) {
<b class="fc">&nbsp;        return getScheduledFuture(initialDelay, period, unit, runnable, this.executor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedule the task, and return a future.
&nbsp;     * The current implementation uses scheduleWithFixedDelay, replacing scheduleWithFixedRate. This avoids queueing issues, but may
&nbsp;     * cause some reporters to skip metrics, as scheduleWithFixedDelay introduces a growing delta from the original start point.
&nbsp;     *
&nbsp;     * Overriding this in a subclass to revert to the old behavior is permitted.
&nbsp;     */
&nbsp;    protected ScheduledFuture&lt;?&gt; getScheduledFuture(long initialDelay, long period, TimeUnit unit, Runnable runnable, ScheduledExecutorService executor) {
<b class="fc">&nbsp;        return executor.scheduleWithFixedDelay(runnable, initialDelay, period, unit);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Starts the reporter polling at the given period.
&nbsp;     *
&nbsp;     * @param initialDelay the time to delay the first execution
&nbsp;     * @param period       the amount of time between polls
&nbsp;     * @param unit         the unit for {@code period} and {@code initialDelay}
&nbsp;     */
&nbsp;    synchronized public void start(long initialDelay, long period, TimeUnit unit) {
<b class="fc">&nbsp;        start(initialDelay, period, unit, () -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                report();</b>
<b class="nc">&nbsp;            } catch (Throwable ex) {</b>
<b class="nc">&nbsp;                LOG.error(&quot;Exception thrown from {}#report. Exception was suppressed.&quot;, ScheduledReporter.this.getClass().getSimpleName(), ex);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        });</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stops the reporter and if shutdownExecutorOnStop is true then shuts down its thread of execution.
&nbsp;     * &lt;p&gt;
&nbsp;     * Uses the shutdown pattern from http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html
&nbsp;     */
&nbsp;    public void stop() {
<b class="pc">&nbsp;        if (shutdownExecutorOnStop) {</b>
<b class="fc">&nbsp;            executor.shutdown(); // Disable new tasks from being submitted</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            report(); // Report metrics one last time</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            LOG.warn(&quot;Final reporting of metrics failed.&quot;, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="pc">&nbsp;        if (shutdownExecutorOnStop) {</b>
&nbsp;            try {
&nbsp;                // Wait a while for existing tasks to terminate
<b class="pc">&nbsp;                if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {</b>
<b class="nc">&nbsp;                    executor.shutdownNow(); // Cancel currently executing tasks</b>
&nbsp;                    // Wait a while for tasks to respond to being cancelled
<b class="nc">&nbsp;                    if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {</b>
<b class="nc">&nbsp;                        LOG.warn(&quot;ScheduledExecutorService did not terminate.&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } catch (InterruptedException ie) {</b>
&nbsp;                // (Re-)Cancel if current thread also interrupted
<b class="nc">&nbsp;                executor.shutdownNow();</b>
&nbsp;                // Preserve interrupt status
<b class="nc">&nbsp;                Thread.currentThread().interrupt();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            // The external manager (like JEE container) responsible for lifecycle of executor
<b class="fc">&nbsp;            cancelScheduledFuture();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private synchronized void cancelScheduledFuture() {
<b class="pc">&nbsp;        if (this.scheduledFuture == null) {</b>
&nbsp;            // was never started
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
<b class="pc">&nbsp;        if (this.scheduledFuture.isCancelled()) {</b>
&nbsp;            // already cancelled
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        // just cancel the scheduledFuture and exit
<b class="fc">&nbsp;        this.scheduledFuture.cancel(false);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stops the reporter and shuts down its thread of execution.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void close() {
<b class="fc">&nbsp;        stop();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Report the current values of all metrics in the registry.
&nbsp;     */
&nbsp;    public void report() {
<b class="fc">&nbsp;        synchronized (this) {</b>
<b class="fc">&nbsp;            report(registry.getGauges(filter),</b>
<b class="fc">&nbsp;                    registry.getCounters(filter),</b>
<b class="fc">&nbsp;                    registry.getHistograms(filter),</b>
<b class="fc">&nbsp;                    registry.getMeters(filter),</b>
<b class="fc">&nbsp;                    registry.getTimers(filter));</b>
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Called periodically by the polling thread. Subclasses should report all the given metrics.
&nbsp;     *
&nbsp;     * @param gauges     all of the gauges in the registry
&nbsp;     * @param counters   all of the counters in the registry
&nbsp;     * @param histograms all of the histograms in the registry
&nbsp;     * @param meters     all of the meters in the registry
&nbsp;     * @param timers     all of the timers in the registry
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    public abstract void report(SortedMap&lt;String, Gauge&gt; gauges,
&nbsp;                                SortedMap&lt;String, Counter&gt; counters,
&nbsp;                                SortedMap&lt;String, Histogram&gt; histograms,
&nbsp;                                SortedMap&lt;String, Meter&gt; meters,
&nbsp;                                SortedMap&lt;String, Timer&gt; timers);
&nbsp;
&nbsp;    protected String getRateUnit() {
<b class="fc">&nbsp;        return rateUnit;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String getDurationUnit() {
<b class="fc">&nbsp;        return durationUnit;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected double convertDuration(double duration) {
<b class="fc">&nbsp;        return duration / durationFactor;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected double convertRate(double rate) {
<b class="fc">&nbsp;        return rate * rateFactor;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean isShutdownExecutorOnStop() {
<b class="nc">&nbsp;        return shutdownExecutorOnStop;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Set&lt;MetricAttribute&gt; getDisabledMetricAttributes() {
<b class="fc">&nbsp;        return disabledMetricAttributes;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String calculateRateUnit(TimeUnit unit) {
<b class="fc">&nbsp;        final String s = unit.toString().toLowerCase(Locale.US);</b>
<b class="fc">&nbsp;        return s.substring(0, s.length() - 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static ScheduledExecutorService createDefaultExecutor(String name) {
<b class="fc">&nbsp;        return Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(name + &#39;-&#39; + FACTORY_ID.incrementAndGet()));</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 00:31</div>
</div>
</body>
</html>
