


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ExponentiallyDecayingReservoir</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.codahale.metrics</a>
</div>

<h1>Coverage Summary for Class: ExponentiallyDecayingReservoir (com.codahale.metrics)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ExponentiallyDecayingReservoir</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (2/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (67/72)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.codahale.metrics;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.concurrent.ConcurrentSkipListMap;
&nbsp;import java.util.concurrent.ThreadLocalRandom;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicLong;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;
&nbsp;import static java.lang.Math.exp;
&nbsp;import static java.lang.Math.min;
&nbsp;
&nbsp;import com.codahale.metrics.WeightedSnapshot.WeightedSample;
&nbsp;
&nbsp;/**
&nbsp; * An exponentially-decaying random reservoir of {@code long}s. Uses Cormode et al&#39;s
&nbsp; * forward-decaying priority reservoir sampling method to produce a statistically representative
&nbsp; * sampling reservoir, exponentially biased towards newer entries.
&nbsp; *
&nbsp; * @see &lt;a href=&quot;http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf&quot;&gt;
&nbsp; * Cormode et al. Forward Decay: A Practical Time Decay Model for Streaming Systems. ICDE &#39;09:
&nbsp; * Proceedings of the 2009 IEEE International Conference on Data Engineering (2009)&lt;/a&gt;
&nbsp; */
&nbsp;public class ExponentiallyDecayingReservoir implements Reservoir {
&nbsp;    private static final int DEFAULT_SIZE = 1028;
&nbsp;    private static final double DEFAULT_ALPHA = 0.015;
<b class="fc">&nbsp;    private static final long RESCALE_THRESHOLD = TimeUnit.HOURS.toNanos(1);</b>
&nbsp;
&nbsp;    private final ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values;
&nbsp;    private final ReentrantReadWriteLock lock;
&nbsp;    private final double alpha;
&nbsp;    private final int size;
&nbsp;    private final AtomicLong count;
&nbsp;    private volatile long startTime;
&nbsp;    private final AtomicLong lastScaleTick;
&nbsp;    private final Clock clock;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ExponentiallyDecayingReservoir} of 1028 elements, which offers a 99.9%
&nbsp;     * confidence level with a 5% margin of error assuming a normal distribution, and an alpha
&nbsp;     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
&nbsp;     */
&nbsp;    public ExponentiallyDecayingReservoir() {
<b class="fc">&nbsp;        this(DEFAULT_SIZE, DEFAULT_ALPHA);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ExponentiallyDecayingReservoir}.
&nbsp;     *
&nbsp;     * @param size  the number of samples to keep in the sampling reservoir
&nbsp;     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
&nbsp;     *              will be towards newer values
&nbsp;     */
&nbsp;    public ExponentiallyDecayingReservoir(int size, double alpha) {
<b class="fc">&nbsp;        this(size, alpha, Clock.defaultClock());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link ExponentiallyDecayingReservoir}.
&nbsp;     *
&nbsp;     * @param size  the number of samples to keep in the sampling reservoir
&nbsp;     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
&nbsp;     *              will be towards newer values
&nbsp;     * @param clock the clock used to timestamp samples and track rescaling
&nbsp;     */
<b class="fc">&nbsp;    public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {</b>
<b class="fc">&nbsp;        this.values = new ConcurrentSkipListMap&lt;&gt;();</b>
<b class="fc">&nbsp;        this.lock = new ReentrantReadWriteLock();</b>
<b class="fc">&nbsp;        this.alpha = alpha;</b>
<b class="fc">&nbsp;        this.size = size;</b>
<b class="fc">&nbsp;        this.clock = clock;</b>
<b class="fc">&nbsp;        this.count = new AtomicLong(0);</b>
<b class="fc">&nbsp;        this.startTime = currentTimeInSeconds();</b>
<b class="fc">&nbsp;        this.lastScaleTick = new AtomicLong(clock.getTick());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public int size() {
<b class="fc">&nbsp;        return (int) min(size, count.get());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void update(long value) {
<b class="fc">&nbsp;        update(value, currentTimeInSeconds());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an old value with a fixed timestamp to the reservoir.
&nbsp;     *
&nbsp;     * @param value     the value to be added
&nbsp;     * @param timestamp the epoch timestamp of {@code value} in seconds
&nbsp;     */
&nbsp;    public void update(long value, long timestamp) {
<b class="fc">&nbsp;        rescaleIfNeeded();</b>
<b class="fc">&nbsp;        lockForRegularUsage();</b>
&nbsp;        try {
<b class="fc">&nbsp;            final double itemWeight = weight(timestamp - startTime);</b>
<b class="fc">&nbsp;            final WeightedSample sample = new WeightedSample(value, itemWeight);</b>
<b class="fc">&nbsp;            final double priority = itemWeight / ThreadLocalRandom.current().nextDouble();</b>
&nbsp;
<b class="fc">&nbsp;            final long newCount = count.incrementAndGet();</b>
<b class="pc">&nbsp;            if (newCount &lt;= size || values.isEmpty()) {</b>
<b class="fc">&nbsp;                values.put(priority, sample);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                Double first = values.firstKey();</b>
<b class="pc">&nbsp;                if (first &lt; priority &amp;&amp; values.putIfAbsent(priority, sample) == null) {</b>
&nbsp;                    // ensure we always remove an item
<b class="pc">&nbsp;                    while (values.remove(first) == null) {</b>
<b class="nc">&nbsp;                        first = values.firstKey();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } finally {
<b class="fc">&nbsp;            unlockForRegularUsage();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void rescaleIfNeeded() {
<b class="fc">&nbsp;        final long now = clock.getTick();</b>
<b class="fc">&nbsp;        final long lastScaleTickSnapshot = lastScaleTick.get();</b>
<b class="pc">&nbsp;        if (now - lastScaleTickSnapshot &gt;= RESCALE_THRESHOLD) {</b>
<b class="fc">&nbsp;            rescale(now, lastScaleTickSnapshot);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public Snapshot getSnapshot() {
<b class="fc">&nbsp;        rescaleIfNeeded();</b>
<b class="fc">&nbsp;        lockForRegularUsage();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return new WeightedSnapshot(values.values());</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            unlockForRegularUsage();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private long currentTimeInSeconds() {
<b class="fc">&nbsp;        return TimeUnit.MILLISECONDS.toSeconds(clock.getTime());</b>
&nbsp;    }
&nbsp;
&nbsp;    private double weight(long t) {
<b class="fc">&nbsp;        return exp(alpha * t);</b>
&nbsp;    }
&nbsp;
&nbsp;    /* &quot;A common feature of the above techniques—indeed, the key technique that
&nbsp;     * allows us to track the decayed weights efficiently—is that they maintain
&nbsp;     * counts and other quantities based on g(ti ? L), and only scale by g(t ? L)
&nbsp;     * at query time. But while g(ti ?L)/g(t?L) is guaranteed to lie between zero
&nbsp;     * and one, the intermediate values of g(ti ? L) could become very large. For
&nbsp;     * polynomial functions, these values should not grow too large, and should be
&nbsp;     * effectively represented in practice by floating point values without loss of
&nbsp;     * precision. For exponential functions, these values could grow quite large as
&nbsp;     * new values of (ti ? L) become large, and potentially exceed the capacity of
&nbsp;     * common floating point types. However, since the values stored by the
&nbsp;     * algorithms are linear combinations of g values (scaled sums), they can be
&nbsp;     * rescaled relative to a new landmark. That is, by the analysis of exponential
&nbsp;     * decay in Section III-A, the choice of L does not affect the final result. We
&nbsp;     * can therefore multiply each value based on L by a factor of exp(??(L? ? L)),
&nbsp;     * and obtain the correct value as if we had instead computed relative to a new
&nbsp;     * landmark L? (and then use this new L? at query time). This can be done with
&nbsp;     * a linear pass over whatever data structure is being used.&quot;
&nbsp;     */
&nbsp;    private void rescale(long now, long lastTick) {
<b class="fc">&nbsp;        lockForRescale();</b>
&nbsp;        try {
<b class="pc">&nbsp;            if (lastScaleTick.compareAndSet(lastTick, now)) {</b>
<b class="fc">&nbsp;                final long oldStartTime = startTime;</b>
<b class="fc">&nbsp;                this.startTime = currentTimeInSeconds();</b>
<b class="fc">&nbsp;                final double scalingFactor = exp(-alpha * (startTime - oldStartTime));</b>
<b class="pc">&nbsp;                if (Double.compare(scalingFactor, 0) == 0) {</b>
<b class="fc">&nbsp;                    values.clear();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    final ArrayList&lt;Double&gt; keys = new ArrayList&lt;&gt;(values.keySet());</b>
<b class="pc">&nbsp;                    for (Double key : keys) {</b>
<b class="fc">&nbsp;                        final WeightedSample sample = values.remove(key);</b>
<b class="fc">&nbsp;                        final WeightedSample newSample = new WeightedSample(sample.value, sample.weight * scalingFactor);</b>
<b class="pc">&nbsp;                        if (Double.compare(newSample.weight, 0) == 0) {</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        values.put(key * scalingFactor, newSample);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                // make sure the counter is in sync with the number of stored samples.
<b class="fc">&nbsp;                count.set(values.size());</b>
&nbsp;            }
&nbsp;        } finally {
<b class="fc">&nbsp;            unlockForRescale();</b>
<b class="fc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void unlockForRescale() {
<b class="fc">&nbsp;        lock.writeLock().unlock();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void lockForRescale() {
<b class="fc">&nbsp;        lock.writeLock().lock();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void lockForRegularUsage() {
<b class="fc">&nbsp;        lock.readLock().lock();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void unlockForRegularUsage() {
<b class="fc">&nbsp;        lock.readLock().unlock();</b>
<b class="fc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 00:31</div>
</div>
</body>
</html>
