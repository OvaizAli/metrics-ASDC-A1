


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > InstrumentedResourceMethodApplicationListener</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.dropwizard.metrics.jersey31</a>
</div>

<h1>Coverage Summary for Class: InstrumentedResourceMethodApplicationListener (io.dropwizard.metrics.jersey31)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InstrumentedResourceMethodApplicationListener</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (16/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.1%
  </span>
  <span class="absValue">
    (82/89)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$ChainedRequestEventListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$EventTypeAndMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (16/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$ExceptionMeterMetric</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$ExceptionMeterRequestEventListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$MeterRequestEventListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$ResponseMeterMetric</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$ResponseMeterRequestEventListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InstrumentedResourceMethodApplicationListener$TimerRequestEventListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (28/28)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95.7%
  </span>
  <span class="absValue">
    (44/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.5%
  </span>
  <span class="absValue">
    (189/200)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package io.dropwizard.metrics.jersey31;
&nbsp;
&nbsp;import com.codahale.metrics.Clock;
&nbsp;import com.codahale.metrics.ExponentiallyDecayingReservoir;
&nbsp;import com.codahale.metrics.Meter;
&nbsp;import com.codahale.metrics.MetricRegistry;
&nbsp;import com.codahale.metrics.Reservoir;
&nbsp;import com.codahale.metrics.Timer;
&nbsp;import com.codahale.metrics.annotation.ExceptionMetered;
&nbsp;import com.codahale.metrics.annotation.Metered;
&nbsp;import com.codahale.metrics.annotation.ResponseMetered;
&nbsp;import com.codahale.metrics.annotation.ResponseMeteredLevel;
&nbsp;import com.codahale.metrics.annotation.Timed;
&nbsp;import jakarta.ws.rs.core.Configuration;
&nbsp;import jakarta.ws.rs.ext.Provider;
&nbsp;import org.glassfish.jersey.server.ContainerResponse;
&nbsp;import org.glassfish.jersey.server.model.ModelProcessor;
&nbsp;import org.glassfish.jersey.server.model.Resource;
&nbsp;import org.glassfish.jersey.server.model.ResourceMethod;
&nbsp;import org.glassfish.jersey.server.model.ResourceModel;
&nbsp;import org.glassfish.jersey.server.monitoring.ApplicationEvent;
&nbsp;import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
&nbsp;import org.glassfish.jersey.server.monitoring.RequestEvent;
&nbsp;import org.glassfish.jersey.server.monitoring.RequestEventListener;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;import static com.codahale.metrics.MetricRegistry.name;
&nbsp;import static com.codahale.metrics.annotation.ResponseMeteredLevel.ALL;
&nbsp;import static com.codahale.metrics.annotation.ResponseMeteredLevel.COARSE;
&nbsp;import static com.codahale.metrics.annotation.ResponseMeteredLevel.DETAILED;
&nbsp;
&nbsp;/**
&nbsp; * An application event listener that listens for Jersey application initialization to
&nbsp; * be finished, then creates a map of resource method that have metrics annotations.
&nbsp; * &lt;p&gt;
&nbsp; * Finally, it listens for method start events, and returns a {@link RequestEventListener}
&nbsp; * that updates the relevant metric for suitably annotated methods when it gets the
&nbsp; * request events indicating that the method is about to be invoked, or just got done
&nbsp; * being invoked.
&nbsp; */
&nbsp;@Provider
&nbsp;public class InstrumentedResourceMethodApplicationListener implements ApplicationEventListener, ModelProcessor {
&nbsp;
<b class="fc">&nbsp;    private static final String[] REQUEST_FILTERING = {&quot;request&quot;, &quot;filtering&quot;};</b>
<b class="fc">&nbsp;    private static final String[] RESPONSE_FILTERING = {&quot;response&quot;, &quot;filtering&quot;};</b>
&nbsp;    private static final String TOTAL = &quot;total&quot;;
&nbsp;
&nbsp;    private final MetricRegistry metrics;
<b class="fc">&nbsp;    private final ConcurrentMap&lt;EventTypeAndMethod, Timer&gt; timers = new ConcurrentHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private final ConcurrentMap&lt;Method, Meter&gt; meters = new ConcurrentHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private final ConcurrentMap&lt;Method, ExceptionMeterMetric&gt; exceptionMeters = new ConcurrentHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;    private final ConcurrentMap&lt;Method, ResponseMeterMetric&gt; responseMeters = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    private final Clock clock;
&nbsp;    private final boolean trackFilters;
&nbsp;    private final Supplier&lt;Reservoir&gt; reservoirSupplier;
&nbsp;
&nbsp;    /**
&nbsp;     * Construct an application event listener using the given metrics registry.
&nbsp;     * &lt;p&gt;
&nbsp;     * When using this constructor, the {@link InstrumentedResourceMethodApplicationListener}
&nbsp;     * should be added to a Jersey {@code ResourceConfig} as a singleton.
&nbsp;     *
&nbsp;     * @param metrics a {@link MetricRegistry}
&nbsp;     */
&nbsp;    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics) {
<b class="nc">&nbsp;        this(metrics, Clock.defaultClock(), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a custom application listener.
&nbsp;     *
&nbsp;     * @param metrics      the metrics registry where the metrics will be stored
&nbsp;     * @param clock        the {@link Clock} to track time (used mostly in testing) in timers
&nbsp;     * @param trackFilters whether the processing time for request and response filters should be tracked
&nbsp;     */
&nbsp;    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
&nbsp;                                                         final boolean trackFilters) {
<b class="nc">&nbsp;        this(metrics, clock, trackFilters, ExponentiallyDecayingReservoir::new);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructs a custom application listener.
&nbsp;     *
&nbsp;     * @param metrics           the metrics registry where the metrics will be stored
&nbsp;     * @param clock             the {@link Clock} to track time (used mostly in testing) in timers
&nbsp;     * @param trackFilters      whether the processing time for request and response filters should be tracked
&nbsp;     * @param reservoirSupplier Supplier for creating the {@link Reservoir} for {@link Timer timers}.
&nbsp;     */
&nbsp;    public InstrumentedResourceMethodApplicationListener(final MetricRegistry metrics, final Clock clock,
&nbsp;                                                         final boolean trackFilters,
<b class="fc">&nbsp;                                                         final Supplier&lt;Reservoir&gt; reservoirSupplier) {</b>
<b class="fc">&nbsp;        this.metrics = metrics;</b>
<b class="fc">&nbsp;        this.clock = clock;</b>
<b class="fc">&nbsp;        this.trackFilters = trackFilters;</b>
<b class="fc">&nbsp;        this.reservoirSupplier = reservoirSupplier;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A private class to maintain the metric for a method annotated with the
&nbsp;     * {@link ExceptionMetered} annotation, which needs to maintain both a meter
&nbsp;     * and a cause for which the meter should be updated.
&nbsp;     */
&nbsp;    private static class ExceptionMeterMetric {
&nbsp;        public final Meter meter;
&nbsp;        public final Class&lt;? extends Throwable&gt; cause;
&nbsp;
&nbsp;        public ExceptionMeterMetric(final MetricRegistry registry,
&nbsp;                                    final ResourceMethod method,
<b class="fc">&nbsp;                                    final ExceptionMetered exceptionMetered) {</b>
<b class="fc">&nbsp;            final String name = chooseName(exceptionMetered.name(),</b>
<b class="fc">&nbsp;                    exceptionMetered.absolute(), method, ExceptionMetered.DEFAULT_NAME_SUFFIX);</b>
<b class="fc">&nbsp;            this.meter = registry.meter(name);</b>
<b class="fc">&nbsp;            this.cause = exceptionMetered.cause();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A private class to maintain the metrics for a method annotated with the
&nbsp;     * {@link ResponseMetered} annotation, which needs to maintain meters for
&nbsp;     * different response codes
&nbsp;     */
&nbsp;    private static class ResponseMeterMetric {
<b class="fc">&nbsp;        private static final Set&lt;ResponseMeteredLevel&gt; COARSE_METER_LEVELS = EnumSet.of(COARSE, ALL);</b>
<b class="fc">&nbsp;        private static final Set&lt;ResponseMeteredLevel&gt; DETAILED_METER_LEVELS = EnumSet.of(DETAILED, ALL);</b>
&nbsp;        private final List&lt;Meter&gt; meters;
&nbsp;        private final Map&lt;Integer, Meter&gt; responseCodeMeters;
&nbsp;        private final MetricRegistry metricRegistry;
&nbsp;        private final String metricName;
&nbsp;        private final ResponseMeteredLevel level;
&nbsp;
&nbsp;        public ResponseMeterMetric(final MetricRegistry registry,
&nbsp;                                   final ResourceMethod method,
<b class="fc">&nbsp;                                   final ResponseMetered responseMetered) {</b>
<b class="fc">&nbsp;            this.metricName = chooseName(responseMetered.name(), responseMetered.absolute(), method);</b>
<b class="fc">&nbsp;            this.level = responseMetered.level();</b>
<b class="fc">&nbsp;            this.meters = COARSE_METER_LEVELS.contains(level) ?</b>
<b class="fc">&nbsp;                    Collections.unmodifiableList(Arrays.asList(</b>
<b class="fc">&nbsp;                            registry.meter(name(metricName, &quot;1xx-responses&quot;)), // 1xx</b>
<b class="fc">&nbsp;                            registry.meter(name(metricName, &quot;2xx-responses&quot;)), // 2xx</b>
<b class="fc">&nbsp;                            registry.meter(name(metricName, &quot;3xx-responses&quot;)), // 3xx</b>
<b class="fc">&nbsp;                            registry.meter(name(metricName, &quot;4xx-responses&quot;)), // 4xx</b>
<b class="fc">&nbsp;                            registry.meter(name(metricName, &quot;5xx-responses&quot;))  // 5xx</b>
<b class="fc">&nbsp;                    )) : Collections.emptyList();</b>
<b class="fc">&nbsp;            this.responseCodeMeters = DETAILED_METER_LEVELS.contains(level) ? new ConcurrentHashMap&lt;&gt;() : Collections.emptyMap();</b>
<b class="fc">&nbsp;            this.metricRegistry = registry;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void mark(int statusCode) {
<b class="fc">&nbsp;            if (DETAILED_METER_LEVELS.contains(level)) {</b>
<b class="fc">&nbsp;                getResponseCodeMeter(statusCode).mark();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (COARSE_METER_LEVELS.contains(level)) {</b>
<b class="fc">&nbsp;                final int responseStatus = statusCode / 100;</b>
<b class="fc">&nbsp;                if (responseStatus &gt;= 1 &amp;&amp; responseStatus &lt;= 5) {</b>
<b class="fc">&nbsp;                    meters.get(responseStatus - 1).mark();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private Meter getResponseCodeMeter(int statusCode) {
<b class="fc">&nbsp;            return responseCodeMeters</b>
<b class="fc">&nbsp;                    .computeIfAbsent(statusCode, sc -&gt; metricRegistry</b>
<b class="fc">&nbsp;                            .meter(name(metricName, String.format(&quot;%d-responses&quot;, sc))));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class TimerRequestEventListener implements RequestEventListener {
&nbsp;
&nbsp;        private final ConcurrentMap&lt;EventTypeAndMethod, Timer&gt; timers;
&nbsp;        private final Clock clock;
&nbsp;        private final long start;
&nbsp;        private Timer.Context resourceMethodStartContext;
&nbsp;        private Timer.Context requestMatchedContext;
&nbsp;        private Timer.Context responseFiltersStartContext;
&nbsp;
<b class="fc">&nbsp;        public TimerRequestEventListener(final ConcurrentMap&lt;EventTypeAndMethod, Timer&gt; timers, final Clock clock) {</b>
<b class="fc">&nbsp;            this.timers = timers;</b>
<b class="fc">&nbsp;            this.clock = clock;</b>
<b class="fc">&nbsp;            start = clock.getTick();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEvent(RequestEvent event) {
<b class="fc">&nbsp;            switch (event.getType()) {</b>
&nbsp;                case RESOURCE_METHOD_START:
<b class="fc">&nbsp;                    resourceMethodStartContext = context(event);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case REQUEST_MATCHED:
<b class="fc">&nbsp;                    requestMatchedContext = context(event);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case RESP_FILTERS_START:
<b class="fc">&nbsp;                    responseFiltersStartContext = context(event);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case RESOURCE_METHOD_FINISHED:
<b class="fc">&nbsp;                    if (resourceMethodStartContext != null) {</b>
<b class="fc">&nbsp;                        resourceMethodStartContext.close();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case REQUEST_FILTERED:
<b class="fc">&nbsp;                    if (requestMatchedContext != null) {</b>
<b class="fc">&nbsp;                        requestMatchedContext.close();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case RESP_FILTERS_FINISHED:
<b class="fc">&nbsp;                    if (responseFiltersStartContext != null) {</b>
<b class="fc">&nbsp;                        responseFiltersStartContext.close();</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                case FINISHED:
<b class="fc">&nbsp;                    if (requestMatchedContext != null &amp;&amp; responseFiltersStartContext != null) {</b>
<b class="fc">&nbsp;                        final Timer timer = timer(event);</b>
<b class="fc">&nbsp;                        if (timer != null) {</b>
<b class="fc">&nbsp;                            timer.update(clock.getTick() - start, TimeUnit.NANOSECONDS);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                    break;
&nbsp;                default:
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private Timer timer(RequestEvent event) {
<b class="fc">&nbsp;            final ResourceMethod resourceMethod = event.getUriInfo().getMatchedResourceMethod();</b>
<b class="fc">&nbsp;            if (resourceMethod == null) {</b>
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
<b class="fc">&nbsp;            return timers.get(new EventTypeAndMethod(event.getType(), resourceMethod.getInvocable().getDefinitionMethod()));</b>
&nbsp;        }
&nbsp;
&nbsp;        private Timer.Context context(RequestEvent event) {
<b class="fc">&nbsp;            final Timer timer = timer(event);</b>
<b class="fc">&nbsp;            return timer != null ? timer.time() : null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class MeterRequestEventListener implements RequestEventListener {
&nbsp;        private final ConcurrentMap&lt;Method, Meter&gt; meters;
&nbsp;
<b class="fc">&nbsp;        public MeterRequestEventListener(final ConcurrentMap&lt;Method, Meter&gt; meters) {</b>
<b class="fc">&nbsp;            this.meters = meters;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEvent(RequestEvent event) {
<b class="fc">&nbsp;            if (event.getType() == RequestEvent.Type.RESOURCE_METHOD_START) {</b>
<b class="fc">&nbsp;                final Meter meter = this.meters.get(event.getUriInfo().getMatchedResourceMethod().getInvocable().getDefinitionMethod());</b>
<b class="fc">&nbsp;                if (meter != null) {</b>
<b class="fc">&nbsp;                    meter.mark();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class ExceptionMeterRequestEventListener implements RequestEventListener {
&nbsp;        private final ConcurrentMap&lt;Method, ExceptionMeterMetric&gt; exceptionMeters;
&nbsp;
<b class="fc">&nbsp;        public ExceptionMeterRequestEventListener(final ConcurrentMap&lt;Method, ExceptionMeterMetric&gt; exceptionMeters) {</b>
<b class="fc">&nbsp;            this.exceptionMeters = exceptionMeters;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEvent(RequestEvent event) {
<b class="fc">&nbsp;            if (event.getType() == RequestEvent.Type.ON_EXCEPTION) {</b>
<b class="fc">&nbsp;                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();</b>
<b class="fc">&nbsp;                final ExceptionMeterMetric metric = (method != null) ?</b>
<b class="fc">&nbsp;                        this.exceptionMeters.get(method.getInvocable().getDefinitionMethod()) : null;</b>
&nbsp;
<b class="fc">&nbsp;                if (metric != null) {</b>
<b class="fc">&nbsp;                    if (metric.cause.isAssignableFrom(event.getException().getClass()) ||</b>
<b class="fc">&nbsp;                            (event.getException().getCause() != null &amp;&amp;</b>
<b class="fc">&nbsp;                                    metric.cause.isAssignableFrom(event.getException().getCause().getClass()))) {</b>
<b class="fc">&nbsp;                        metric.meter.mark();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class ResponseMeterRequestEventListener implements RequestEventListener {
&nbsp;        private final ConcurrentMap&lt;Method, ResponseMeterMetric&gt; responseMeters;
&nbsp;
<b class="fc">&nbsp;        public ResponseMeterRequestEventListener(final ConcurrentMap&lt;Method, ResponseMeterMetric&gt; responseMeters) {</b>
<b class="fc">&nbsp;            this.responseMeters = responseMeters;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEvent(RequestEvent event) {
<b class="fc">&nbsp;            if (event.getType() == RequestEvent.Type.FINISHED) {</b>
<b class="fc">&nbsp;                final ResourceMethod method = event.getUriInfo().getMatchedResourceMethod();</b>
<b class="fc">&nbsp;                final ResponseMeterMetric metric = (method != null) ?</b>
<b class="fc">&nbsp;                        this.responseMeters.get(method.getInvocable().getDefinitionMethod()) : null;</b>
&nbsp;
<b class="fc">&nbsp;                if (metric != null) {</b>
<b class="fc">&nbsp;                    ContainerResponse containerResponse = event.getContainerResponse();</b>
<b class="fc">&nbsp;                    if (containerResponse == null &amp;&amp; event.getException() != null) {</b>
<b class="nc">&nbsp;                        metric.mark(500);</b>
<b class="fc">&nbsp;                    } else if (containerResponse != null) {</b>
<b class="fc">&nbsp;                        metric.mark(containerResponse.getStatus());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class ChainedRequestEventListener implements RequestEventListener {</b>
&nbsp;        private final RequestEventListener[] listeners;
&nbsp;
<b class="fc">&nbsp;        private ChainedRequestEventListener(final RequestEventListener... listeners) {</b>
<b class="fc">&nbsp;            this.listeners = listeners;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEvent(final RequestEvent event) {
<b class="fc">&nbsp;            for (RequestEventListener listener : listeners) {</b>
<b class="fc">&nbsp;                listener.onEvent(event);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onEvent(ApplicationEvent event) {
<b class="fc">&nbsp;        if (event.getType() == ApplicationEvent.Type.INITIALIZATION_APP_FINISHED) {</b>
<b class="fc">&nbsp;            registerMetricsForModel(event.getResourceModel());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
<b class="fc">&nbsp;        return resourceModel;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
<b class="fc">&nbsp;        registerMetricsForModel(subResourceModel);</b>
<b class="fc">&nbsp;        return subResourceModel;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void registerMetricsForModel(ResourceModel resourceModel) {
<b class="fc">&nbsp;        for (final Resource resource : resourceModel.getResources()) {</b>
&nbsp;
<b class="fc">&nbsp;            final Timed classLevelTimed = getClassLevelAnnotation(resource, Timed.class);</b>
<b class="fc">&nbsp;            final Metered classLevelMetered = getClassLevelAnnotation(resource, Metered.class);</b>
<b class="fc">&nbsp;            final ExceptionMetered classLevelExceptionMetered = getClassLevelAnnotation(resource, ExceptionMetered.class);</b>
<b class="fc">&nbsp;            final ResponseMetered classLevelResponseMetered = getClassLevelAnnotation(resource, ResponseMetered.class);</b>
&nbsp;
<b class="fc">&nbsp;            for (final ResourceMethod method : resource.getAllMethods()) {</b>
<b class="nc">&nbsp;                registerTimedAnnotations(method, classLevelTimed);</b>
<b class="nc">&nbsp;                registerMeteredAnnotations(method, classLevelMetered);</b>
<b class="nc">&nbsp;                registerExceptionMeteredAnnotations(method, classLevelExceptionMetered);</b>
<b class="nc">&nbsp;                registerResponseMeteredAnnotations(method, classLevelResponseMetered);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            for (final Resource childResource : resource.getChildResources()) {</b>
&nbsp;
<b class="fc">&nbsp;                final Timed classLevelTimedChild = getClassLevelAnnotation(childResource, Timed.class);</b>
<b class="fc">&nbsp;                final Metered classLevelMeteredChild = getClassLevelAnnotation(childResource, Metered.class);</b>
<b class="fc">&nbsp;                final ExceptionMetered classLevelExceptionMeteredChild = getClassLevelAnnotation(childResource, ExceptionMetered.class);</b>
<b class="fc">&nbsp;                final ResponseMetered classLevelResponseMeteredChild = getClassLevelAnnotation(childResource, ResponseMetered.class);</b>
&nbsp;
<b class="fc">&nbsp;                for (final ResourceMethod method : childResource.getAllMethods()) {</b>
<b class="fc">&nbsp;                    registerTimedAnnotations(method, classLevelTimedChild);</b>
<b class="fc">&nbsp;                    registerMeteredAnnotations(method, classLevelMeteredChild);</b>
<b class="fc">&nbsp;                    registerExceptionMeteredAnnotations(method, classLevelExceptionMeteredChild);</b>
<b class="fc">&nbsp;                    registerResponseMeteredAnnotations(method, classLevelResponseMeteredChild);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RequestEventListener onRequest(final RequestEvent event) {
<b class="fc">&nbsp;        final RequestEventListener listener = new ChainedRequestEventListener(</b>
&nbsp;                new TimerRequestEventListener(timers, clock),
&nbsp;                new MeterRequestEventListener(meters),
&nbsp;                new ExceptionMeterRequestEventListener(exceptionMeters),
&nbsp;                new ResponseMeterRequestEventListener(responseMeters));
&nbsp;
<b class="fc">&nbsp;        return listener;</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T extends Annotation&gt; T getClassLevelAnnotation(final Resource resource, final Class&lt;T&gt; annotationClazz) {
<b class="fc">&nbsp;        T annotation = null;</b>
&nbsp;
<b class="fc">&nbsp;        for (final Class&lt;?&gt; clazz : resource.getHandlerClasses()) {</b>
<b class="fc">&nbsp;            annotation = clazz.getAnnotation(annotationClazz);</b>
&nbsp;
<b class="fc">&nbsp;            if (annotation != null) {</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return annotation;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void registerTimedAnnotations(final ResourceMethod method, final Timed classLevelTimed) {
<b class="fc">&nbsp;        final Method definitionMethod = method.getInvocable().getDefinitionMethod();</b>
<b class="fc">&nbsp;        if (classLevelTimed != null) {</b>
<b class="fc">&nbsp;            registerTimers(method, definitionMethod, classLevelTimed);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        final Timed annotation = definitionMethod.getAnnotation(Timed.class);</b>
<b class="fc">&nbsp;        if (annotation != null) {</b>
<b class="fc">&nbsp;            registerTimers(method, definitionMethod, annotation);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void registerTimers(ResourceMethod method, Method definitionMethod, Timed annotation) {
<b class="fc">&nbsp;        timers.putIfAbsent(EventTypeAndMethod.requestMethodStart(definitionMethod), timerMetric(metrics, method, annotation));</b>
<b class="fc">&nbsp;        if (trackFilters) {</b>
<b class="fc">&nbsp;            timers.putIfAbsent(EventTypeAndMethod.requestMatched(definitionMethod), timerMetric(metrics, method, annotation, REQUEST_FILTERING));</b>
<b class="fc">&nbsp;            timers.putIfAbsent(EventTypeAndMethod.respFiltersStart(definitionMethod), timerMetric(metrics, method, annotation, RESPONSE_FILTERING));</b>
<b class="fc">&nbsp;            timers.putIfAbsent(EventTypeAndMethod.finished(definitionMethod), timerMetric(metrics, method, annotation, TOTAL));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void registerMeteredAnnotations(final ResourceMethod method, final Metered classLevelMetered) {
<b class="fc">&nbsp;        final Method definitionMethod = method.getInvocable().getDefinitionMethod();</b>
&nbsp;
<b class="fc">&nbsp;        if (classLevelMetered != null) {</b>
<b class="fc">&nbsp;            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, classLevelMetered));</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        final Metered annotation = definitionMethod.getAnnotation(Metered.class);</b>
&nbsp;
<b class="fc">&nbsp;        if (annotation != null) {</b>
<b class="fc">&nbsp;            meters.putIfAbsent(definitionMethod, meterMetric(metrics, method, annotation));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void registerExceptionMeteredAnnotations(final ResourceMethod method, final ExceptionMetered classLevelExceptionMetered) {
<b class="fc">&nbsp;        final Method definitionMethod = method.getInvocable().getDefinitionMethod();</b>
&nbsp;
<b class="fc">&nbsp;        if (classLevelExceptionMetered != null) {</b>
<b class="fc">&nbsp;            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, classLevelExceptionMetered));</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        final ExceptionMetered annotation = definitionMethod.getAnnotation(ExceptionMetered.class);</b>
&nbsp;
<b class="fc">&nbsp;        if (annotation != null) {</b>
<b class="fc">&nbsp;            exceptionMeters.putIfAbsent(definitionMethod, new ExceptionMeterMetric(metrics, method, annotation));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void registerResponseMeteredAnnotations(final ResourceMethod method, final ResponseMetered classLevelResponseMetered) {
<b class="fc">&nbsp;        final Method definitionMethod = method.getInvocable().getDefinitionMethod();</b>
&nbsp;
<b class="fc">&nbsp;        if (classLevelResponseMetered != null) {</b>
<b class="fc">&nbsp;            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, classLevelResponseMetered));</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        final ResponseMetered annotation = definitionMethod.getAnnotation(ResponseMetered.class);</b>
&nbsp;
<b class="fc">&nbsp;        if (annotation != null) {</b>
<b class="fc">&nbsp;            responseMeters.putIfAbsent(definitionMethod, new ResponseMeterMetric(metrics, method, annotation));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Timer timerMetric(final MetricRegistry registry,
&nbsp;                              final ResourceMethod method,
&nbsp;                              final Timed timed,
&nbsp;                              final String... suffixes) {
<b class="fc">&nbsp;        final String name = chooseName(timed.name(), timed.absolute(), method, suffixes);</b>
<b class="fc">&nbsp;        return registry.timer(name, () -&gt; new Timer(reservoirSupplier.get(), clock));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Meter meterMetric(final MetricRegistry registry,
&nbsp;                              final ResourceMethod method,
&nbsp;                              final Metered metered) {
<b class="fc">&nbsp;        final String name = chooseName(metered.name(), metered.absolute(), method);</b>
<b class="fc">&nbsp;        return registry.meter(name, () -&gt; new Meter(clock));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected static String chooseName(final String explicitName, final boolean absolute, final ResourceMethod method,
&nbsp;                                       final String... suffixes) {
<b class="fc">&nbsp;        final Method definitionMethod = method.getInvocable().getDefinitionMethod();</b>
&nbsp;        final String metricName;
<b class="fc">&nbsp;        if (explicitName != null &amp;&amp; !explicitName.isEmpty()) {</b>
<b class="fc">&nbsp;            metricName = absolute ? explicitName : name(definitionMethod.getDeclaringClass(), explicitName);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            metricName = name(definitionMethod.getDeclaringClass(), definitionMethod.getName());</b>
&nbsp;        }
<b class="fc">&nbsp;        return name(metricName, suffixes);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class EventTypeAndMethod {</b>
&nbsp;
&nbsp;        private final RequestEvent.Type type;
&nbsp;        private final Method method;
&nbsp;
<b class="fc">&nbsp;        private EventTypeAndMethod(RequestEvent.Type type, Method method) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.method = method;</b>
&nbsp;        }
&nbsp;
&nbsp;        static EventTypeAndMethod requestMethodStart(Method method) {
<b class="fc">&nbsp;            return new EventTypeAndMethod(RequestEvent.Type.RESOURCE_METHOD_START, method);</b>
&nbsp;        }
&nbsp;
&nbsp;        static EventTypeAndMethod requestMatched(Method method) {
<b class="fc">&nbsp;            return new EventTypeAndMethod(RequestEvent.Type.REQUEST_MATCHED, method);</b>
&nbsp;        }
&nbsp;
&nbsp;        static EventTypeAndMethod respFiltersStart(Method method) {
<b class="fc">&nbsp;            return new EventTypeAndMethod(RequestEvent.Type.RESP_FILTERS_START, method);</b>
&nbsp;        }
&nbsp;
&nbsp;        static EventTypeAndMethod finished(Method method) {
<b class="fc">&nbsp;            return new EventTypeAndMethod(RequestEvent.Type.FINISHED, method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="fc">&nbsp;            if (this == o) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            EventTypeAndMethod that = (EventTypeAndMethod) o;</b>
&nbsp;
<b class="fc">&nbsp;            if (type != that.type) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            return method.equals(that.method);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = type.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + method.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-01 18:42</div>
</div>
</body>
</html>
