<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExponentiallyDecayingReservoirTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in metrics-log4j2 Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.codahale.metrics</a> &gt; <span class="el_source">ExponentiallyDecayingReservoirTest.java</span></div><h1>ExponentiallyDecayingReservoirTest.java</h1><pre class="source lang-java linenums">package com.codahale.metrics;

import com.codahale.metrics.Timer.Context;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(Parameterized.class)
public class ExponentiallyDecayingReservoirTest {

<span class="nc" id="L20">    public enum ReservoirFactory {</span>
<span class="nc" id="L21">        EXPONENTIALLY_DECAYING() {</span>
            @Override
            Reservoir create(int size, double alpha, Clock clock) {
<span class="nc" id="L24">                return new ExponentiallyDecayingReservoir(size, alpha, clock);</span>
            }
        },

<span class="nc" id="L28">        LOCK_FREE_EXPONENTIALLY_DECAYING() {</span>
            @Override
            Reservoir create(int size, double alpha, Clock clock) {
<span class="nc" id="L31">                return LockFreeExponentiallyDecayingReservoir.builder()</span>
<span class="nc" id="L32">                        .size(size)</span>
<span class="nc" id="L33">                        .alpha(alpha)</span>
<span class="nc" id="L34">                        .clock(clock)</span>
<span class="nc" id="L35">                        .build();</span>
            }
        };

        abstract Reservoir create(int size, double alpha, Clock clock);

        Reservoir create(int size, double alpha) {
<span class="nc" id="L42">            return create(size, alpha, Clock.defaultClock());</span>
        }
    }

    @Parameterized.Parameters(name = &quot;{index}: {0}&quot;)
    public static Collection&lt;Object[]&gt; reservoirs() {
<span class="nc" id="L48">        return Arrays.stream(ReservoirFactory.values())</span>
<span class="nc" id="L49">                .map(value -&gt; new Object[] {value})</span>
<span class="nc" id="L50">                .collect(Collectors.toList());</span>
    }

    private final ReservoirFactory reservoirFactory;

<span class="nc" id="L55">    public ExponentiallyDecayingReservoirTest(ReservoirFactory reservoirFactory) {</span>
<span class="nc" id="L56">        this.reservoirFactory = reservoirFactory;</span>
<span class="nc" id="L57">    }</span>

    @Test
    public void aReservoirOf100OutOf1000Elements() {
<span class="nc" id="L61">        final Reservoir reservoir = reservoirFactory.create(100, 0.99);</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="nc" id="L63">            reservoir.update(i);</span>
        }

<span class="nc" id="L66">        assertThat(reservoir.size())</span>
<span class="nc" id="L67">                .isEqualTo(100);</span>

<span class="nc" id="L69">        final Snapshot snapshot = reservoir.getSnapshot();</span>

<span class="nc" id="L71">        assertThat(snapshot.size())</span>
<span class="nc" id="L72">                .isEqualTo(100);</span>

<span class="nc" id="L74">        assertAllValuesBetween(reservoir, 0, 1000);</span>
<span class="nc" id="L75">    }</span>

    @Test
    public void aReservoirOf100OutOf10Elements() {
<span class="nc" id="L79">        final Reservoir reservoir = reservoirFactory.create(100, 0.99);</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L81">            reservoir.update(i);</span>
        }

<span class="nc" id="L84">        final Snapshot snapshot = reservoir.getSnapshot();</span>

<span class="nc" id="L86">        assertThat(snapshot.size())</span>
<span class="nc" id="L87">                .isEqualTo(10);</span>

<span class="nc" id="L89">        assertThat(snapshot.size())</span>
<span class="nc" id="L90">                .isEqualTo(10);</span>

<span class="nc" id="L92">        assertAllValuesBetween(reservoir, 0, 10);</span>
<span class="nc" id="L93">    }</span>

    @Test
    public void aHeavilyBiasedReservoirOf100OutOf1000Elements() {
<span class="nc" id="L97">        final Reservoir reservoir = reservoirFactory.create(1000, 0.01);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="nc" id="L99">            reservoir.update(i);</span>
        }


<span class="nc" id="L103">        assertThat(reservoir.size())</span>
<span class="nc" id="L104">                .isEqualTo(100);</span>

<span class="nc" id="L106">        final Snapshot snapshot = reservoir.getSnapshot();</span>

<span class="nc" id="L108">        assertThat(snapshot.size())</span>
<span class="nc" id="L109">                .isEqualTo(100);</span>

<span class="nc" id="L111">        assertAllValuesBetween(reservoir, 0, 100);</span>
<span class="nc" id="L112">    }</span>

    @Test
    public void longPeriodsOfInactivityShouldNotCorruptSamplingState() {
<span class="nc" id="L116">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L117">        final Reservoir reservoir = reservoirFactory.create(10, 0.15, clock);</span>

        // add 1000 values at a rate of 10 values/second
<span class="nc bnc" id="L120" title="All 2 branches missed.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="nc" id="L121">            reservoir.update(1000 + i);</span>
<span class="nc" id="L122">            clock.addMillis(100);</span>
        }
<span class="nc" id="L124">        assertThat(reservoir.getSnapshot().size())</span>
<span class="nc" id="L125">                .isEqualTo(10);</span>
<span class="nc" id="L126">        assertAllValuesBetween(reservoir, 1000, 2000);</span>

        // wait for 15 hours and add another value.
        // this should trigger a rescale. Note that the number of samples will be reduced to 1
        // because scaling factor equal to zero will remove all existing entries after rescale.
<span class="nc" id="L131">        clock.addHours(15);</span>
<span class="nc" id="L132">        reservoir.update(2000);</span>
<span class="nc" id="L133">        assertThat(reservoir.getSnapshot().size())</span>
<span class="nc" id="L134">                .isEqualTo(1);</span>
<span class="nc" id="L135">        assertAllValuesBetween(reservoir, 1000, 2001);</span>


        // add 1000 values at a rate of 10 values/second
<span class="nc bnc" id="L139" title="All 2 branches missed.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="nc" id="L140">            reservoir.update(3000 + i);</span>
<span class="nc" id="L141">            clock.addMillis(100);</span>
        }
<span class="nc" id="L143">        assertThat(reservoir.getSnapshot().size())</span>
<span class="nc" id="L144">                .isEqualTo(10);</span>
<span class="nc" id="L145">        assertAllValuesBetween(reservoir, 3000, 4000);</span>
<span class="nc" id="L146">    }</span>

    @Test
    public void longPeriodsOfInactivity_fetchShouldResample() {
<span class="nc" id="L150">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L151">        final Reservoir reservoir = reservoirFactory.create(10,</span>
                0.015,
                clock);

        // add 1000 values at a rate of 10 values/second
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="nc" id="L157">            reservoir.update(1000 + i);</span>
<span class="nc" id="L158">            clock.addMillis(100);</span>
        }
<span class="nc" id="L160">        assertThat(reservoir.getSnapshot().size())</span>
<span class="nc" id="L161">                .isEqualTo(10);</span>
<span class="nc" id="L162">        assertAllValuesBetween(reservoir, 1000, 2000);</span>

        // wait for 20 hours and take snapshot.
        // this should trigger a rescale. Note that the number of samples will be reduced to 0
        // because scaling factor equal to zero will remove all existing entries after rescale.
<span class="nc" id="L167">        clock.addHours(20);</span>
<span class="nc" id="L168">        Snapshot snapshot = reservoir.getSnapshot();</span>
<span class="nc" id="L169">        assertThat(snapshot.getMax()).isEqualTo(0);</span>
<span class="nc" id="L170">        assertThat(snapshot.getMean()).isEqualTo(0);</span>
<span class="nc" id="L171">        assertThat(snapshot.getMedian()).isEqualTo(0);</span>
<span class="nc" id="L172">        assertThat(snapshot.size()).isEqualTo(0);</span>
<span class="nc" id="L173">    }</span>

    @Test
    public void emptyReservoirSnapshot_shouldReturnZeroForAllValues() {
<span class="nc" id="L177">        final Reservoir reservoir = reservoirFactory.create(100, 0.015,</span>
                new ManualClock());

<span class="nc" id="L180">        Snapshot snapshot = reservoir.getSnapshot();</span>
<span class="nc" id="L181">        assertThat(snapshot.getMax()).isEqualTo(0);</span>
<span class="nc" id="L182">        assertThat(snapshot.getMean()).isEqualTo(0);</span>
<span class="nc" id="L183">        assertThat(snapshot.getMedian()).isEqualTo(0);</span>
<span class="nc" id="L184">        assertThat(snapshot.size()).isEqualTo(0);</span>
<span class="nc" id="L185">    }</span>

    @Test
    public void removeZeroWeightsInSamplesToPreventNaNInMeanValues() {
<span class="nc" id="L189">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L190">        final Reservoir reservoir = reservoirFactory.create(1028, 0.015, clock);</span>
<span class="nc" id="L191">        Timer timer = new Timer(reservoir, clock);</span>

<span class="nc" id="L193">        Context context = timer.time();</span>
<span class="nc" id="L194">        clock.addMillis(100);</span>
<span class="nc" id="L195">        context.stop();</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">        for (int i = 1; i &lt; 48; i++) {</span>
<span class="nc" id="L198">            clock.addHours(1);</span>
<span class="nc" id="L199">            assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);</span>
        }
<span class="nc" id="L201">    }</span>

    @Test
    public void multipleUpdatesAfterlongPeriodsOfInactivityShouldNotCorruptSamplingState() throws Exception {
        // This test illustrates the potential race condition in rescale that
        // can lead to a corrupt state.  Note that while this test uses updates
        // exclusively to trigger the race condition, two concurrent updates
        // may be made much more likely to trigger this behavior if executed
        // while another thread is constructing a snapshot of the reservoir;
        // that thread then holds the read lock when the two competing updates
        // are executed and the race condition's window is substantially
        // expanded.

        // Run the test several times.
<span class="nc bnc" id="L215" title="All 2 branches missed.">        for (int attempt = 0; attempt &lt; 10; attempt++) {</span>
<span class="nc" id="L216">            final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L217">            final Reservoir reservoir = reservoirFactory.create(10,</span>
                    0.015,
                    clock);

            // Various atomics used to communicate between this thread and the
            // thread created below.
<span class="nc" id="L223">            final AtomicBoolean running = new AtomicBoolean(true);</span>
<span class="nc" id="L224">            final AtomicInteger threadUpdates = new AtomicInteger(0);</span>
<span class="nc" id="L225">            final AtomicInteger testUpdates = new AtomicInteger(0);</span>

<span class="nc" id="L227">            final Thread thread = new Thread(() -&gt; {</span>
<span class="nc" id="L228">                int previous = 0;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                while (running.get()) {</span>
                    // Wait for the test thread to update it's counter
                    // before updaing the reservoir.
                    while (true) {
<span class="nc" id="L233">                        int next = testUpdates.get();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                        if (previous &lt; next) {</span>
<span class="nc" id="L235">                            previous = next;</span>
<span class="nc" id="L236">                            break;</span>
                        }
<span class="nc" id="L238">                    }</span>

                    // Update the reservoir.  This needs to occur at the
                    // same time as the test thread's update.
<span class="nc" id="L242">                    reservoir.update(1000);</span>

                    // Signal the main thread; allows the next update
                    // attempt to begin.
<span class="nc" id="L246">                    threadUpdates.incrementAndGet();</span>
                }
<span class="nc" id="L248">            });</span>

<span class="nc" id="L250">            thread.start();</span>

<span class="nc" id="L252">            int sum = 0;</span>
<span class="nc" id="L253">            int previous = -1;</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            for (int i = 0; i &lt; 100; i++) {</span>
                // Wait for 15 hours before attempting the next concurrent
                // update.  The delay here needs to be sufficiently long to
                // overflow if an update attempt is allowed to add a value to
                // the reservoir without rescaling.  Note that:
                // e(alpha*(15*60*60)) =~ 10^351 &gt;&gt; Double.MAX_VALUE =~ 1.8*10^308.
<span class="nc" id="L260">                clock.addHours(15);</span>

                // Signal the other thread; asynchronously updates the reservoir.
<span class="nc" id="L263">                testUpdates.incrementAndGet();</span>

                // Delay a variable length of time.  Without a delay here this
                // thread is heavily favored and the race condition is almost
                // never observed.
<span class="nc bnc" id="L268" title="All 2 branches missed.">                for (int j = 0; j &lt; i; j++)</span>
<span class="nc" id="L269">                    sum += j;</span>

                // Competing reservoir update.
<span class="nc" id="L272">                reservoir.update(1000);</span>

                // Wait for the other thread to finish it's update.
                while (true) {
<span class="nc" id="L276">                    int next = threadUpdates.get();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                    if (previous &lt; next) {</span>
<span class="nc" id="L278">                        previous = next;</span>
<span class="nc" id="L279">                        break;</span>
                    }
<span class="nc" id="L281">                }</span>
            }

            // Terminate the thread.
<span class="nc" id="L285">            running.set(false);</span>
<span class="nc" id="L286">            testUpdates.incrementAndGet();</span>
<span class="nc" id="L287">            thread.join();</span>

            // Test failures will result in normWeights that are not finite;
            // checking the mean value here is sufficient.
<span class="nc" id="L291">            assertThat(reservoir.getSnapshot().getMean()).isBetween(0.0, Double.MAX_VALUE);</span>

            // Check the value of sum; should prevent the JVM from optimizing
            // out the delay loop entirely.
<span class="nc" id="L295">            assertThat(sum).isEqualTo(161700);</span>
        }
<span class="nc" id="L297">    }</span>

    @Test
    public void spotLift() {
<span class="nc" id="L301">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L302">        final Reservoir reservoir = reservoirFactory.create(1000,</span>
                0.015,
                clock);

<span class="nc" id="L306">        final int valuesRatePerMinute = 10;</span>
<span class="nc" id="L307">        final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);</span>
        // mode 1: steady regime for 120 minutes
<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (int i = 0; i &lt; 120 * valuesRatePerMinute; i++) {</span>
<span class="nc" id="L310">            reservoir.update(177);</span>
<span class="nc" id="L311">            clock.addMillis(valuesIntervalMillis);</span>
        }

        // switching to mode 2: 10 minutes more with the same rate, but larger value
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int i = 0; i &lt; 10 * valuesRatePerMinute; i++) {</span>
<span class="nc" id="L316">            reservoir.update(9999);</span>
<span class="nc" id="L317">            clock.addMillis(valuesIntervalMillis);</span>
        }

        // expect that quantiles should be more about mode 2 after 10 minutes
<span class="nc" id="L321">        assertThat(reservoir.getSnapshot().getMedian())</span>
<span class="nc" id="L322">                .isEqualTo(9999);</span>
<span class="nc" id="L323">    }</span>

    @Test
    public void spotFall() {
<span class="nc" id="L327">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L328">        final Reservoir reservoir = reservoirFactory.create(1000,</span>
                0.015,
                clock);

<span class="nc" id="L332">        final int valuesRatePerMinute = 10;</span>
<span class="nc" id="L333">        final int valuesIntervalMillis = (int) (TimeUnit.MINUTES.toMillis(1) / valuesRatePerMinute);</span>
        // mode 1: steady regime for 120 minutes
<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (int i = 0; i &lt; 120 * valuesRatePerMinute; i++) {</span>
<span class="nc" id="L336">            reservoir.update(9998);</span>
<span class="nc" id="L337">            clock.addMillis(valuesIntervalMillis);</span>
        }

        // switching to mode 2: 10 minutes more with the same rate, but smaller value
<span class="nc bnc" id="L341" title="All 2 branches missed.">        for (int i = 0; i &lt; 10 * valuesRatePerMinute; i++) {</span>
<span class="nc" id="L342">            reservoir.update(178);</span>
<span class="nc" id="L343">            clock.addMillis(valuesIntervalMillis);</span>
        }

        // expect that quantiles should be more about mode 2 after 10 minutes
<span class="nc" id="L347">        assertThat(reservoir.getSnapshot().get95thPercentile())</span>
<span class="nc" id="L348">                .isEqualTo(178);</span>
<span class="nc" id="L349">    }</span>

    @Test
    public void quantiliesShouldBeBasedOnWeights() {
<span class="nc" id="L353">        final ManualClock clock = new ManualClock();</span>
<span class="nc" id="L354">        final Reservoir reservoir = reservoirFactory.create(1000,</span>
                0.015,
                clock);
<span class="nc bnc" id="L357" title="All 2 branches missed.">        for (int i = 0; i &lt; 40; i++) {</span>
<span class="nc" id="L358">            reservoir.update(177);</span>
        }

<span class="nc" id="L361">        clock.addSeconds(120);</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L364">            reservoir.update(9999);</span>
        }

<span class="nc" id="L367">        assertThat(reservoir.getSnapshot().size())</span>
<span class="nc" id="L368">                .isEqualTo(50);</span>

        // the first added 40 items (177) have weights 1 
        // the next added 10 items (9999) have weights ~6 
        // so, it's 40 vs 60 distribution, not 40 vs 10
<span class="nc" id="L373">        assertThat(reservoir.getSnapshot().getMedian())</span>
<span class="nc" id="L374">                .isEqualTo(9999);</span>
<span class="nc" id="L375">        assertThat(reservoir.getSnapshot().get75thPercentile())</span>
<span class="nc" id="L376">                .isEqualTo(9999);</span>
<span class="nc" id="L377">    }</span>

    @Test
    public void clockWrapShouldNotRescale() {
        // First verify the test works as expected given low values
<span class="nc" id="L382">        testShortPeriodShouldNotRescale(0);</span>
        // Now revalidate using an edge case nanoTime value just prior to wrapping
<span class="nc" id="L384">        testShortPeriodShouldNotRescale(Long.MAX_VALUE - TimeUnit.MINUTES.toNanos(30));</span>
<span class="nc" id="L385">    }</span>

    private void testShortPeriodShouldNotRescale(long startTimeNanos) {
<span class="nc" id="L388">        final ManualClock clock = new ManualClock(startTimeNanos);</span>
<span class="nc" id="L389">        final Reservoir reservoir = reservoirFactory.create(10, 1, clock);</span>

<span class="nc" id="L391">        reservoir.update(1000);</span>
<span class="nc" id="L392">        assertThat(reservoir.getSnapshot().size()).isEqualTo(1);</span>

<span class="nc" id="L394">        assertAllValuesBetween(reservoir, 1000, 1001);</span>

        // wait for 10 millis and take snapshot.
        // this should not trigger a rescale. Note that the number of samples will be reduced to 0
        // because scaling factor equal to zero will remove all existing entries after rescale.
<span class="nc" id="L399">        clock.addSeconds(20 * 60);</span>
<span class="nc" id="L400">        Snapshot snapshot = reservoir.getSnapshot();</span>
<span class="nc" id="L401">        assertThat(snapshot.getMax()).isEqualTo(1000);</span>
<span class="nc" id="L402">        assertThat(snapshot.getMean()).isEqualTo(1000);</span>
<span class="nc" id="L403">        assertThat(snapshot.getMedian()).isEqualTo(1000);</span>
<span class="nc" id="L404">        assertThat(snapshot.size()).isEqualTo(1);</span>
<span class="nc" id="L405">    }</span>

    private static void assertAllValuesBetween(Reservoir reservoir,
                                               double min,
                                               double max) {
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (double i : reservoir.getSnapshot().getValues()) {</span>
<span class="nc" id="L411">            assertThat(i)</span>
<span class="nc" id="L412">                    .isLessThan(max)</span>
<span class="nc" id="L413">                    .isGreaterThanOrEqualTo(min);</span>
        }
<span class="nc" id="L415">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>