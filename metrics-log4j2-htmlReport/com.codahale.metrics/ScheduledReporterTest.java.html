<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScheduledReporterTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in metrics-log4j2 Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.codahale.metrics</a> &gt; <span class="el_source">ScheduledReporterTest.java</span></div><h1>ScheduledReporterTest.java</h1><pre class="source lang-java linenums">package com.codahale.metrics;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

<span class="nc" id="L28">public class ScheduledReporterTest {</span>
<span class="nc" id="L29">    private final Gauge&lt;String&gt; gauge = () -&gt; &quot;&quot;;</span>
<span class="nc" id="L30">    private final Counter counter = mock(Counter.class);</span>
<span class="nc" id="L31">    private final Histogram histogram = mock(Histogram.class);</span>
<span class="nc" id="L32">    private final Meter meter = mock(Meter.class);</span>
<span class="nc" id="L33">    private final Timer timer = mock(Timer.class);</span>

<span class="nc" id="L35">    private final ScheduledExecutorService mockExecutor = mock(ScheduledExecutorService.class);</span>
<span class="nc" id="L36">    private final ScheduledExecutorService customExecutor = Executors.newSingleThreadScheduledExecutor();</span>
<span class="nc" id="L37">    private final ScheduledExecutorService externalExecutor = Executors.newSingleThreadScheduledExecutor();</span>

<span class="nc" id="L39">    private final MetricRegistry registry = new MetricRegistry();</span>
<span class="nc" id="L40">    private final ScheduledReporter reporter = spy(</span>
            new DummyReporter(registry, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS)
    );
<span class="nc" id="L43">    private final ScheduledReporter reporterWithNullExecutor = spy(</span>
            new DummyReporter(registry, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, null)
    );
<span class="nc" id="L46">    private final ScheduledReporter reporterWithCustomMockExecutor = new DummyReporter(registry, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, mockExecutor);</span>
<span class="nc" id="L47">    private final ScheduledReporter reporterWithCustomExecutor = new DummyReporter(registry, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, customExecutor);</span>
<span class="nc" id="L48">    private final DummyReporter reporterWithExternallyManagedExecutor = new DummyReporter(registry, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, externalExecutor, false);</span>
<span class="nc" id="L49">    private final ScheduledReporter[] reporters = new ScheduledReporter[] {reporter, reporterWithCustomExecutor, reporterWithExternallyManagedExecutor};</span>

    @Before
    @SuppressWarnings(&quot;unchecked&quot;)
    public void setUp() throws Exception {
<span class="nc" id="L54">        registry.register(&quot;gauge&quot;, gauge);</span>
<span class="nc" id="L55">        registry.register(&quot;counter&quot;, counter);</span>
<span class="nc" id="L56">        registry.register(&quot;histogram&quot;, histogram);</span>
<span class="nc" id="L57">        registry.register(&quot;meter&quot;, meter);</span>
<span class="nc" id="L58">        registry.register(&quot;timer&quot;, timer);</span>
<span class="nc" id="L59">    }</span>

    @After
    public void tearDown() throws Exception {
<span class="nc" id="L63">        customExecutor.shutdown();</span>
<span class="nc" id="L64">        externalExecutor.shutdown();</span>
<span class="nc" id="L65">        reporter.stop();</span>
<span class="nc" id="L66">        reporterWithNullExecutor.stop();</span>
<span class="nc" id="L67">    }</span>

    @Test
    public void createWithNullMetricRegistry() {
<span class="nc" id="L71">        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();</span>
<span class="nc" id="L72">        DummyReporter r = null;</span>
        try {
<span class="nc" id="L74">            r = new DummyReporter(null, &quot;example&quot;, MetricFilter.ALL, TimeUnit.SECONDS, TimeUnit.MILLISECONDS, executor);</span>
<span class="nc" id="L75">            Assert.fail(&quot;NullPointerException must be thrown !!!&quot;);</span>
<span class="nc" id="L76">        } catch (NullPointerException e) {</span>
<span class="nc" id="L77">            Assert.assertEquals(&quot;registry == null&quot;, e.getMessage());</span>
        } finally {
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L80">                r.close();</span>
            }
        }
<span class="nc" id="L83">    }</span>

    @Test
    public void pollsPeriodically() throws Exception {
<span class="nc" id="L87">        CountDownLatch latch = new CountDownLatch(2);</span>
<span class="nc" id="L88">        reporter.start(100, 100, TimeUnit.MILLISECONDS, () -&gt; {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (latch.getCount() &gt; 0) {</span>
<span class="nc" id="L90">                reporter.report();</span>
<span class="nc" id="L91">                latch.countDown();</span>
            }
<span class="nc" id="L93">        });</span>
<span class="nc" id="L94">        latch.await(5, TimeUnit.SECONDS);</span>

<span class="nc" id="L96">        verify(reporter, times(2)).report(</span>
<span class="nc" id="L97">                map(&quot;gauge&quot;, gauge),</span>
<span class="nc" id="L98">                map(&quot;counter&quot;, counter),</span>
<span class="nc" id="L99">                map(&quot;histogram&quot;, histogram),</span>
<span class="nc" id="L100">                map(&quot;meter&quot;, meter),</span>
<span class="nc" id="L101">                map(&quot;timer&quot;, timer)</span>
        );
<span class="nc" id="L103">    }</span>

    @Test
    public void shouldUsePeriodAsInitialDelayIfNotSpecifiedOtherwise() throws Exception {
<span class="nc" id="L107">        reporterWithCustomMockExecutor.start(200, TimeUnit.MILLISECONDS);</span>

<span class="nc" id="L109">        verify(mockExecutor, times(1)).scheduleWithFixedDelay(</span>
<span class="nc" id="L110">            any(Runnable.class), eq(200L), eq(200L), eq(TimeUnit.MILLISECONDS)</span>
        );
<span class="nc" id="L112">    }</span>

    @Test
    public void shouldStartWithSpecifiedInitialDelay() throws Exception {
<span class="nc" id="L116">        reporterWithCustomMockExecutor.start(350, 100, TimeUnit.MILLISECONDS);</span>

<span class="nc" id="L118">        verify(mockExecutor).scheduleWithFixedDelay(</span>
<span class="nc" id="L119">            any(Runnable.class), eq(350L), eq(100L), eq(TimeUnit.MILLISECONDS)</span>
        );
<span class="nc" id="L121">    }</span>

    @Test
    public void shouldAutoCreateExecutorWhenItNull() throws Exception {
<span class="nc" id="L125">        CountDownLatch latch = new CountDownLatch(2);</span>
<span class="nc" id="L126">        reporterWithNullExecutor.start(100, 100, TimeUnit.MILLISECONDS, () -&gt; {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            if (latch.getCount() &gt; 0) {</span>
<span class="nc" id="L128">                reporterWithNullExecutor.report();</span>
<span class="nc" id="L129">                latch.countDown();</span>
            }
<span class="nc" id="L131">        });</span>
<span class="nc" id="L132">        latch.await(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L133">        verify(reporterWithNullExecutor, times(2)).report(</span>
<span class="nc" id="L134">                map(&quot;gauge&quot;, gauge),</span>
<span class="nc" id="L135">                map(&quot;counter&quot;, counter),</span>
<span class="nc" id="L136">                map(&quot;histogram&quot;, histogram),</span>
<span class="nc" id="L137">                map(&quot;meter&quot;, meter),</span>
<span class="nc" id="L138">                map(&quot;timer&quot;, timer)</span>
        );
<span class="nc" id="L140">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void shouldDisallowToStartReportingMultiple() throws Exception {
<span class="nc" id="L144">        reporter.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L145">        reporter.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L146">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void shouldDisallowToStartReportingMultipleTimesOnCustomExecutor() throws Exception {
<span class="nc" id="L150">        reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L151">        reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L152">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void shouldDisallowToStartReportingMultipleTimesOnExternallyManagedExecutor() throws Exception {
<span class="nc" id="L156">        reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L157">        reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L158">    }</span>

    @Test
    public void shouldNotFailOnStopIfReporterWasNotStared() {
<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (ScheduledReporter reporter : reporters) {</span>
<span class="nc" id="L163">            reporter.stop();</span>
        }
<span class="nc" id="L165">    }</span>

    @Test
    public void shouldNotFailWhenStoppingMultipleTimes() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (ScheduledReporter reporter : reporters) {</span>
<span class="nc" id="L170">            reporter.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L171">            reporter.stop();</span>
<span class="nc" id="L172">            reporter.stop();</span>
<span class="nc" id="L173">            reporter.stop();</span>
        }
<span class="nc" id="L175">    }</span>

    @Test
    public void shouldShutdownExecutorOnStopByDefault() {
<span class="nc" id="L179">        reporterWithCustomExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L180">        reporterWithCustomExecutor.stop();</span>
<span class="nc" id="L181">        assertTrue(customExecutor.isTerminated());</span>
<span class="nc" id="L182">    }</span>

    @Test
    public void shouldNotShutdownExternallyManagedExecutorOnStop() {
<span class="nc" id="L186">        reporterWithExternallyManagedExecutor.start(200, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L187">        reporterWithExternallyManagedExecutor.stop();</span>
<span class="nc" id="L188">        assertFalse(mockExecutor.isTerminated());</span>
<span class="nc" id="L189">        assertFalse(mockExecutor.isShutdown());</span>
<span class="nc" id="L190">    }</span>

    @Test
    public void shouldCancelScheduledFutureWhenStoppingWithExternallyManagedExecutor() throws InterruptedException, ExecutionException, TimeoutException {
        // configure very frequency rate of execution
<span class="nc" id="L195">        reporterWithExternallyManagedExecutor.start(1, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L196">        reporterWithExternallyManagedExecutor.stop();</span>
<span class="nc" id="L197">        Thread.sleep(100);</span>

        // executionCount should not increase when scheduled future is canceled properly
<span class="nc" id="L200">        int executionCount = reporterWithExternallyManagedExecutor.executionCount.get();</span>
<span class="nc" id="L201">        Thread.sleep(500);</span>
<span class="nc" id="L202">        assertEquals(executionCount, reporterWithExternallyManagedExecutor.executionCount.get());</span>
<span class="nc" id="L203">    }</span>

    @Test
    public void shouldConvertDurationToMillisecondsPrecisely() {
<span class="nc" id="L207">        assertEquals(2.0E-5, reporter.convertDuration(20), 0.0);</span>
<span class="nc" id="L208">    }</span>

    @Test
    public void shouldReportMetricsOnShutdown() throws Exception {
<span class="nc" id="L212">        CountDownLatch latch = new CountDownLatch(1);</span>
<span class="nc" id="L213">        reporterWithNullExecutor.start(0, 10, TimeUnit.SECONDS, () -&gt; {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (latch.getCount() &gt; 0) {</span>
<span class="nc" id="L215">                reporterWithNullExecutor.report();</span>
<span class="nc" id="L216">                latch.countDown();</span>
            }
<span class="nc" id="L218">        });</span>
<span class="nc" id="L219">        latch.await(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L220">        reporterWithNullExecutor.stop();</span>

<span class="nc" id="L222">        verify(reporterWithNullExecutor, times(2)).report(</span>
<span class="nc" id="L223">                map(&quot;gauge&quot;, gauge),</span>
<span class="nc" id="L224">                map(&quot;counter&quot;, counter),</span>
<span class="nc" id="L225">                map(&quot;histogram&quot;, histogram),</span>
<span class="nc" id="L226">                map(&quot;meter&quot;, meter),</span>
<span class="nc" id="L227">                map(&quot;timer&quot;, timer)</span>
        );
<span class="nc" id="L229">    }</span>

    @Test
    public void shouldRescheduleAfterReportFinish() throws Exception {
        // the first report is triggered at T + 0.1 seconds and takes 0.8 seconds
        // after the first report finishes at T + 0.9 seconds the next report is scheduled to run at T + 1.4 seconds
<span class="nc" id="L235">        reporter.start(100, 500, TimeUnit.MILLISECONDS, () -&gt; {</span>
<span class="nc" id="L236">            reporter.report();</span>
            try {
<span class="nc" id="L238">                Thread.sleep(800);</span>
<span class="nc" id="L239">            } catch (InterruptedException e) {</span>
<span class="nc" id="L240">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L241">            }</span>
<span class="nc" id="L242">        });</span>

<span class="nc" id="L244">        Thread.sleep(1_000);</span>

<span class="nc" id="L246">        verify(reporter, times(1)).report(</span>
<span class="nc" id="L247">                map(&quot;gauge&quot;, gauge),</span>
<span class="nc" id="L248">                map(&quot;counter&quot;, counter),</span>
<span class="nc" id="L249">                map(&quot;histogram&quot;, histogram),</span>
<span class="nc" id="L250">                map(&quot;meter&quot;, meter),</span>
<span class="nc" id="L251">                map(&quot;timer&quot;, timer)</span>
        );
<span class="nc" id="L253">    }</span>

    private &lt;T&gt; SortedMap&lt;String, T&gt; map(String name, T value) {
<span class="nc" id="L256">        final SortedMap&lt;String, T&gt; map = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L257">        map.put(name, value);</span>
<span class="nc" id="L258">        return map;</span>
    }

    private static class DummyReporter extends ScheduledReporter {

<span class="nc" id="L263">        private AtomicInteger executionCount = new AtomicInteger();</span>

        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit) {
<span class="nc" id="L266">            super(registry, name, filter, rateUnit, durationUnit);</span>
<span class="nc" id="L267">        }</span>

        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit, ScheduledExecutorService executor) {
<span class="nc" id="L270">            super(registry, name, filter, rateUnit, durationUnit, executor);</span>
<span class="nc" id="L271">        }</span>

        DummyReporter(MetricRegistry registry, String name, MetricFilter filter, TimeUnit rateUnit, TimeUnit durationUnit, ScheduledExecutorService executor, boolean shutdownExecutorOnStop) {
<span class="nc" id="L274">            super(registry, name, filter, rateUnit, durationUnit, executor, shutdownExecutorOnStop);</span>
<span class="nc" id="L275">        }</span>

        @Override
        @SuppressWarnings(&quot;rawtypes&quot;)
        public void report(SortedMap&lt;String, Gauge&gt; gauges, SortedMap&lt;String, Counter&gt; counters, SortedMap&lt;String, Histogram&gt; histograms, SortedMap&lt;String, Meter&gt; meters, SortedMap&lt;String, Timer&gt; timers) {
<span class="nc" id="L280">            executionCount.incrementAndGet();</span>
            // nothing doing!
<span class="nc" id="L282">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>