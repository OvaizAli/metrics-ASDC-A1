<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExponentiallyDecayingReservoir.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in metrics-log4j2 Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.codahale.metrics</a> &gt; <span class="el_source">ExponentiallyDecayingReservoir.java</span></div><h1>ExponentiallyDecayingReservoir.java</h1><pre class="source lang-java linenums">package com.codahale.metrics;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import static java.lang.Math.exp;
import static java.lang.Math.min;

import com.codahale.metrics.WeightedSnapshot.WeightedSample;

/**
 * An exponentially-decaying random reservoir of {@code long}s. Uses Cormode et al's
 * forward-decaying priority reservoir sampling method to produce a statistically representative
 * sampling reservoir, exponentially biased towards newer entries.
 *
 * @see &lt;a href=&quot;http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf&quot;&gt;
 * Cormode et al. Forward Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09:
 * Proceedings of the 2009 IEEE International Conference on Data Engineering (2009)&lt;/a&gt;
 */
public class ExponentiallyDecayingReservoir implements Reservoir {
    private static final int DEFAULT_SIZE = 1028;
    private static final double DEFAULT_ALPHA = 0.015;
<span class="nc" id="L27">    private static final long RESCALE_THRESHOLD = TimeUnit.HOURS.toNanos(1);</span>

    private final ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values;
    private final ReentrantReadWriteLock lock;
    private final double alpha;
    private final int size;
    private final AtomicLong count;
    private volatile long startTime;
    private final AtomicLong lastScaleTick;
    private final Clock clock;

    /**
     * Creates a new {@link ExponentiallyDecayingReservoir} of 1028 elements, which offers a 99.9%
     * confidence level with a 5% margin of error assuming a normal distribution, and an alpha
     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
     */
    public ExponentiallyDecayingReservoir() {
<span class="nc" id="L44">        this(DEFAULT_SIZE, DEFAULT_ALPHA);</span>
<span class="nc" id="L45">    }</span>

    /**
     * Creates a new {@link ExponentiallyDecayingReservoir}.
     *
     * @param size  the number of samples to keep in the sampling reservoir
     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
     *              will be towards newer values
     */
    public ExponentiallyDecayingReservoir(int size, double alpha) {
<span class="nc" id="L55">        this(size, alpha, Clock.defaultClock());</span>
<span class="nc" id="L56">    }</span>

    /**
     * Creates a new {@link ExponentiallyDecayingReservoir}.
     *
     * @param size  the number of samples to keep in the sampling reservoir
     * @param alpha the exponential decay factor; the higher this is, the more biased the reservoir
     *              will be towards newer values
     * @param clock the clock used to timestamp samples and track rescaling
     */
<span class="nc" id="L66">    public ExponentiallyDecayingReservoir(int size, double alpha, Clock clock) {</span>
<span class="nc" id="L67">        this.values = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="nc" id="L68">        this.lock = new ReentrantReadWriteLock();</span>
<span class="nc" id="L69">        this.alpha = alpha;</span>
<span class="nc" id="L70">        this.size = size;</span>
<span class="nc" id="L71">        this.clock = clock;</span>
<span class="nc" id="L72">        this.count = new AtomicLong(0);</span>
<span class="nc" id="L73">        this.startTime = currentTimeInSeconds();</span>
<span class="nc" id="L74">        this.lastScaleTick = new AtomicLong(clock.getTick());</span>
<span class="nc" id="L75">    }</span>

    @Override
    public int size() {
<span class="nc" id="L79">        return (int) min(size, count.get());</span>
    }

    @Override
    public void update(long value) {
<span class="nc" id="L84">        update(value, currentTimeInSeconds());</span>
<span class="nc" id="L85">    }</span>

    /**
     * Adds an old value with a fixed timestamp to the reservoir.
     *
     * @param value     the value to be added
     * @param timestamp the epoch timestamp of {@code value} in seconds
     */
    public void update(long value, long timestamp) {
<span class="nc" id="L94">        rescaleIfNeeded();</span>
<span class="nc" id="L95">        lockForRegularUsage();</span>
        try {
<span class="nc" id="L97">            final double itemWeight = weight(timestamp - startTime);</span>
<span class="nc" id="L98">            final WeightedSample sample = new WeightedSample(value, itemWeight);</span>
<span class="nc" id="L99">            final double priority = itemWeight / ThreadLocalRandom.current().nextDouble();</span>

<span class="nc" id="L101">            final long newCount = count.incrementAndGet();</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">            if (newCount &lt;= size || values.isEmpty()) {</span>
<span class="nc" id="L103">                values.put(priority, sample);</span>
            } else {
<span class="nc" id="L105">                Double first = values.firstKey();</span>
<span class="nc bnc" id="L106" title="All 4 branches missed.">                if (first &lt; priority &amp;&amp; values.putIfAbsent(priority, sample) == null) {</span>
                    // ensure we always remove an item
<span class="nc bnc" id="L108" title="All 2 branches missed.">                    while (values.remove(first) == null) {</span>
<span class="nc" id="L109">                        first = values.firstKey();</span>
                    }
                }
            }
        } finally {
<span class="nc" id="L114">            unlockForRegularUsage();</span>
        }
<span class="nc" id="L116">    }</span>

    private void rescaleIfNeeded() {
<span class="nc" id="L119">        final long now = clock.getTick();</span>
<span class="nc" id="L120">        final long lastScaleTickSnapshot = lastScaleTick.get();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (now - lastScaleTickSnapshot &gt;= RESCALE_THRESHOLD) {</span>
<span class="nc" id="L122">            rescale(now, lastScaleTickSnapshot);</span>
        }
<span class="nc" id="L124">    }</span>

    @Override
    public Snapshot getSnapshot() {
<span class="nc" id="L128">        rescaleIfNeeded();</span>
<span class="nc" id="L129">        lockForRegularUsage();</span>
        try {
<span class="nc" id="L131">            return new WeightedSnapshot(values.values());</span>
        } finally {
<span class="nc" id="L133">            unlockForRegularUsage();</span>
        }
    }

    private long currentTimeInSeconds() {
<span class="nc" id="L138">        return TimeUnit.MILLISECONDS.toSeconds(clock.getTime());</span>
    }

    private double weight(long t) {
<span class="nc" id="L142">        return exp(alpha * t);</span>
    }

    /* &quot;A common feature of the above techniques—indeed, the key technique that
     * allows us to track the decayed weights efficiently—is that they maintain
     * counts and other quantities based on g(ti − L), and only scale by g(t − L)
     * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
     * and one, the intermediate values of g(ti − L) could become very large. For
     * polynomial functions, these values should not grow too large, and should be
     * effectively represented in practice by floating point values without loss of
     * precision. For exponential functions, these values could grow quite large as
     * new values of (ti − L) become large, and potentially exceed the capacity of
     * common floating point types. However, since the values stored by the
     * algorithms are linear combinations of g values (scaled sums), they can be
     * rescaled relative to a new landmark. That is, by the analysis of exponential
     * decay in Section III-A, the choice of L does not affect the final result. We
     * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
     * and obtain the correct value as if we had instead computed relative to a new
     * landmark L′ (and then use this new L′ at query time). This can be done with
     * a linear pass over whatever data structure is being used.&quot;
     */
    private void rescale(long now, long lastTick) {
<span class="nc" id="L164">        lockForRescale();</span>
        try {
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (lastScaleTick.compareAndSet(lastTick, now)) {</span>
<span class="nc" id="L167">                final long oldStartTime = startTime;</span>
<span class="nc" id="L168">                this.startTime = currentTimeInSeconds();</span>
<span class="nc" id="L169">                final double scalingFactor = exp(-alpha * (startTime - oldStartTime));</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (Double.compare(scalingFactor, 0) == 0) {</span>
<span class="nc" id="L171">                    values.clear();</span>
                } else {
<span class="nc" id="L173">                    final ArrayList&lt;Double&gt; keys = new ArrayList&lt;&gt;(values.keySet());</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                    for (Double key : keys) {</span>
<span class="nc" id="L175">                        final WeightedSample sample = values.remove(key);</span>
<span class="nc" id="L176">                        final WeightedSample newSample = new WeightedSample(sample.value, sample.weight * scalingFactor);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if (Double.compare(newSample.weight, 0) == 0) {</span>
<span class="nc" id="L178">                            continue;</span>
                        }
<span class="nc" id="L180">                        values.put(key * scalingFactor, newSample);</span>
<span class="nc" id="L181">                    }</span>
                }

                // make sure the counter is in sync with the number of stored samples.
<span class="nc" id="L185">                count.set(values.size());</span>
            }
        } finally {
<span class="nc" id="L188">            unlockForRescale();</span>
        }
<span class="nc" id="L190">    }</span>

    private void unlockForRescale() {
<span class="nc" id="L193">        lock.writeLock().unlock();</span>
<span class="nc" id="L194">    }</span>

    private void lockForRescale() {
<span class="nc" id="L197">        lock.writeLock().lock();</span>
<span class="nc" id="L198">    }</span>

    private void lockForRegularUsage() {
<span class="nc" id="L201">        lock.readLock().lock();</span>
<span class="nc" id="L202">    }</span>

    private void unlockForRegularUsage() {
<span class="nc" id="L205">        lock.readLock().unlock();</span>
<span class="nc" id="L206">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>