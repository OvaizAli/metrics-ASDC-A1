<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChunkedAssociativeLongArray.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in metrics-log4j2 Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.codahale.metrics</a> &gt; <span class="el_source">ChunkedAssociativeLongArray.java</span></div><h1>ChunkedAssociativeLongArray.java</h1><pre class="source lang-java linenums">package com.codahale.metrics;

import java.lang.ref.SoftReference;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Iterator;

import static java.lang.System.arraycopy;
import static java.util.Arrays.binarySearch;

class ChunkedAssociativeLongArray {
<span class="nc" id="L12">    private static final long[] EMPTY = new long[0];</span>
    private static final int DEFAULT_CHUNK_SIZE = 512;
    private static final int MAX_CACHE_SIZE = 128;

    private final int defaultChunkSize;

    /*
     * We use this ArrayDeque as cache to store chunks that are expired and removed from main data structure.
     * Then instead of allocating new Chunk immediately we are trying to poll one from this deque.
     * So if you have constant or slowly changing load ChunkedAssociativeLongArray will never
     * throw away old chunks or allocate new ones which makes this data structure almost garbage free.
     */
<span class="nc" id="L24">    private final ArrayDeque&lt;SoftReference&lt;Chunk&gt;&gt; chunksCache = new ArrayDeque&lt;&gt;();</span>

<span class="nc" id="L26">    private final Deque&lt;Chunk&gt; chunks = new ArrayDeque&lt;&gt;();</span>

    ChunkedAssociativeLongArray() {
<span class="nc" id="L29">        this(DEFAULT_CHUNK_SIZE);</span>
<span class="nc" id="L30">    }</span>

<span class="nc" id="L32">    ChunkedAssociativeLongArray(int chunkSize) {</span>
<span class="nc" id="L33">        this.defaultChunkSize = chunkSize;</span>
<span class="nc" id="L34">    }</span>

    private Chunk allocateChunk() {
        while (true) {
<span class="nc" id="L38">            final SoftReference&lt;Chunk&gt; chunkRef = chunksCache.pollLast();</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">            if (chunkRef == null) {</span>
<span class="nc" id="L40">                return new Chunk(defaultChunkSize);</span>
            }
<span class="nc" id="L42">            final Chunk chunk = chunkRef.get();</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">            if (chunk != null) {</span>
<span class="nc" id="L44">                chunk.cursor = 0;</span>
<span class="nc" id="L45">                chunk.startIndex = 0;</span>
<span class="nc" id="L46">                chunk.chunkSize = chunk.keys.length;</span>
<span class="nc" id="L47">                return chunk;</span>
            }
<span class="nc" id="L49">        }</span>
    }

    private void freeChunk(Chunk chunk) {
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (chunksCache.size() &lt; MAX_CACHE_SIZE) {</span>
<span class="nc" id="L54">            chunksCache.add(new SoftReference&lt;&gt;(chunk));</span>
        }
<span class="nc" id="L56">    }</span>

    synchronized boolean put(long key, long value) {
<span class="nc" id="L59">        Chunk activeChunk = chunks.peekLast();</span>
<span class="nc bnc" id="L60" title="All 6 branches missed.">        if (activeChunk != null &amp;&amp; activeChunk.cursor != 0 &amp;&amp; activeChunk.keys[activeChunk.cursor - 1] &gt; key) {</span>
            // key should be the same as last inserted or bigger
<span class="nc" id="L62">            return false;</span>
        }
<span class="nc bnc" id="L64" title="All 4 branches missed.">        if (activeChunk == null || activeChunk.cursor - activeChunk.startIndex == activeChunk.chunkSize) {</span>
            // The last chunk doesn't exist or full
<span class="nc" id="L66">            activeChunk = allocateChunk();</span>
<span class="nc" id="L67">            chunks.add(activeChunk);</span>
        }
<span class="nc" id="L69">        activeChunk.append(key, value);</span>
<span class="nc" id="L70">        return true;</span>
    }

    synchronized long[] values() {
<span class="nc" id="L74">        final int valuesSize = size();</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (valuesSize == 0) {</span>
<span class="nc" id="L76">            return EMPTY;</span>
        }

<span class="nc" id="L79">        final long[] values = new long[valuesSize];</span>
<span class="nc" id="L80">        int valuesIndex = 0;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (Chunk chunk : chunks) {</span>
<span class="nc" id="L82">            int length = chunk.cursor - chunk.startIndex;</span>
<span class="nc" id="L83">            int itemsToCopy = Math.min(valuesSize - valuesIndex, length);</span>
<span class="nc" id="L84">            arraycopy(chunk.values, chunk.startIndex, values, valuesIndex, itemsToCopy);</span>
<span class="nc" id="L85">            valuesIndex += length;</span>
<span class="nc" id="L86">        }</span>
<span class="nc" id="L87">        return values;</span>
    }

    synchronized int size() {
<span class="nc" id="L91">        int result = 0;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        for (Chunk chunk : chunks) {</span>
<span class="nc" id="L93">            result += chunk.cursor - chunk.startIndex;</span>
<span class="nc" id="L94">        }</span>
<span class="nc" id="L95">        return result;</span>
    }

    synchronized String out() {
<span class="nc" id="L99">        final StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L100">        final Iterator&lt;Chunk&gt; iterator = chunks.iterator();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L102">            final Chunk chunk = iterator.next();</span>
<span class="nc" id="L103">            builder.append('[');</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">            for (int i = chunk.startIndex; i &lt; chunk.cursor; i++) {</span>
<span class="nc" id="L105">                builder.append('(').append(chunk.keys[i]).append(&quot;: &quot;)</span>
<span class="nc" id="L106">                        .append(chunk.values[i]).append(')').append(' ');</span>
            }
<span class="nc" id="L108">            builder.append(']');</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (iterator.hasNext()) {</span>
<span class="nc" id="L110">                builder.append(&quot;-&gt;&quot;);</span>
            }
<span class="nc" id="L112">        }</span>
<span class="nc" id="L113">        return builder.toString();</span>
    }

    /**
     * Try to trim all beyond specified boundaries.
     *
     * @param startKey the start value for which all elements less than it should be removed.
     * @param endKey   the end value for which all elements greater/equals than it should be removed.
     */
    synchronized void trim(long startKey, long endKey) {
        /*
         * [3, 4, 5, 9] -&gt; [10, 13, 14, 15] -&gt; [21, 24, 29, 30] -&gt; [31] :: start layout
         *       |5______________________________23|                    :: trim(5, 23)
         *       [5, 9] -&gt; [10, 13, 14, 15] -&gt; [21]                     :: result layout
         */
<span class="nc" id="L128">        final Iterator&lt;Chunk&gt; descendingIterator = chunks.descendingIterator();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        while (descendingIterator.hasNext()) {</span>
<span class="nc" id="L130">            final Chunk currentTail = descendingIterator.next();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (isFirstElementIsEmptyOrGreaterEqualThanKey(currentTail, endKey)) {</span>
<span class="nc" id="L132">                freeChunk(currentTail);</span>
<span class="nc" id="L133">                descendingIterator.remove();</span>
            } else {
<span class="nc" id="L135">                currentTail.cursor = findFirstIndexOfGreaterEqualElements(currentTail.keys, currentTail.startIndex,</span>
<span class="nc" id="L136">                        currentTail.cursor, endKey);</span>
<span class="nc" id="L137">                break;</span>
            }
<span class="nc" id="L139">        }</span>

<span class="nc" id="L141">        final Iterator&lt;Chunk&gt; iterator = chunks.iterator();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L143">            final Chunk currentHead = iterator.next();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (isLastElementIsLessThanKey(currentHead, startKey)) {</span>
<span class="nc" id="L145">                freeChunk(currentHead);</span>
<span class="nc" id="L146">                iterator.remove();</span>
            } else {
<span class="nc" id="L148">                final int newStartIndex = findFirstIndexOfGreaterEqualElements(currentHead.keys, currentHead.startIndex,</span>
<span class="nc" id="L149">                        currentHead.cursor, startKey);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                if (currentHead.startIndex != newStartIndex) {</span>
<span class="nc" id="L151">                    currentHead.startIndex = newStartIndex;</span>
<span class="nc" id="L152">                    currentHead.chunkSize = currentHead.cursor - currentHead.startIndex;</span>
                }
                break;
            }
<span class="nc" id="L156">        }</span>
<span class="nc" id="L157">    }</span>

    synchronized void clear() {
<span class="nc" id="L160">        chunks.clear();</span>
<span class="nc" id="L161">    }</span>

    private boolean isFirstElementIsEmptyOrGreaterEqualThanKey(Chunk chunk, long key) {
<span class="nc bnc" id="L164" title="All 4 branches missed.">        return chunk.cursor == chunk.startIndex || chunk.keys[chunk.startIndex] &gt;= key;</span>
    }

    private boolean isLastElementIsLessThanKey(Chunk chunk, long key) {
<span class="nc bnc" id="L168" title="All 4 branches missed.">        return chunk.cursor == chunk.startIndex || chunk.keys[chunk.cursor - 1] &lt; key;</span>
    }

    private int findFirstIndexOfGreaterEqualElements(long[] array, int startIndex, int endIndex, long minKey) {
<span class="nc bnc" id="L172" title="All 4 branches missed.">        if (endIndex == startIndex || array[startIndex] &gt;= minKey) {</span>
<span class="nc" id="L173">            return startIndex;</span>
        }
<span class="nc" id="L175">        final int keyIndex = binarySearch(array, startIndex, endIndex, minKey);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        return keyIndex &lt; 0 ? -(keyIndex + 1) : keyIndex;</span>
    }

    private static class Chunk {

        private final long[] keys;
        private final long[] values;

        private int chunkSize; // can differ from keys.length after half clear()
<span class="nc" id="L185">        private int startIndex = 0;</span>
<span class="nc" id="L186">        private int cursor = 0;</span>

<span class="nc" id="L188">        private Chunk(int chunkSize) {</span>
<span class="nc" id="L189">            this.chunkSize = chunkSize;</span>
<span class="nc" id="L190">            this.keys = new long[chunkSize];</span>
<span class="nc" id="L191">            this.values = new long[chunkSize];</span>
<span class="nc" id="L192">        }</span>

        private void append(long key, long value) {
<span class="nc" id="L195">            keys[cursor] = key;</span>
<span class="nc" id="L196">            values[cursor] = value;</span>
<span class="nc" id="L197">            cursor++;</span>
<span class="nc" id="L198">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>