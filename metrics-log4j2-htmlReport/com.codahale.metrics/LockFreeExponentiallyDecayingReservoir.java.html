<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LockFreeExponentiallyDecayingReservoir.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">All in metrics-log4j2 Coverage Results</a> &gt; <a href="index.source.html" class="el_package">com.codahale.metrics</a> &gt; <span class="el_source">LockFreeExponentiallyDecayingReservoir.java</span></div><h1>LockFreeExponentiallyDecayingReservoir.java</h1><pre class="source lang-java linenums">package com.codahale.metrics;

import com.codahale.metrics.WeightedSnapshot.WeightedSample;

import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.BiConsumer;

/**
 * A lock-free exponentially-decaying random reservoir of {@code long}s. Uses Cormode et al's
 * forward-decaying priority reservoir sampling method to produce a statistically representative
 * sampling reservoir, exponentially biased towards newer entries.
 *
 * @see &lt;a href=&quot;http://dimacs.rutgers.edu/~graham/pubs/papers/fwddecay.pdf&quot;&gt;
 * Cormode et al. Forward Decay: A Practical Time Decay Model for Streaming Systems. ICDE '09:
 * Proceedings of the 2009 IEEE International Conference on Data Engineering (2009)&lt;/a&gt;
 *
 * {@link LockFreeExponentiallyDecayingReservoir} is based closely on the {@link ExponentiallyDecayingReservoir},
 * however it provides looser guarantees while completely avoiding locks.
 *
 * Looser guarantees:
 * &lt;ul&gt;
 *     &lt;li&gt; Updates which occur concurrently with rescaling may be discarded if the orphaned state node is updated after
 *     rescale has replaced it. This condition has a greater probability as the rescale interval is reduced due to the
 *     increased frequency of rescaling. {@link #rescaleThresholdNanos} values below 30 seconds are not recommended.
 *     &lt;li&gt; Given a small rescale threshold, updates may attempt to rescale into a new bucket, but lose the CAS race
 *     and update into a newer bucket than expected. In these cases the measurement weight is reduced accordingly.
 *     &lt;li&gt;In the worst case, all concurrent threads updating the reservoir may attempt to rescale rather than
 *     a single thread holding an exclusive write lock. It's expected that the configuration is set such that
 *     rescaling is substantially less common than updating at peak load. Even so, when size is reasonably small
 *     it can be more efficient to rescale than to park and context switch.
 * &lt;/ul&gt;
 *
 * @author &lt;a href=&quot;mailto:ckozak@ckozak.net&quot;&gt;Carter Kozak&lt;/a&gt;
 */
public final class LockFreeExponentiallyDecayingReservoir implements Reservoir {

    private static final double SECONDS_PER_NANO = .000_000_001D;
<span class="nc" id="L43">    private static final AtomicReferenceFieldUpdater&lt;LockFreeExponentiallyDecayingReservoir, State&gt; stateUpdater =</span>
<span class="nc" id="L44">            AtomicReferenceFieldUpdater.newUpdater(LockFreeExponentiallyDecayingReservoir.class, State.class, &quot;state&quot;);</span>

    private final int size;
    private final long rescaleThresholdNanos;
    private final Clock clock;

    private volatile State state;

    private static final class State {

<span class="nc" id="L54">        private static final AtomicIntegerFieldUpdater&lt;State&gt; countUpdater =</span>
<span class="nc" id="L55">                AtomicIntegerFieldUpdater.newUpdater(State.class, &quot;count&quot;);</span>

        private final double alphaNanos;
        private final int size;
        private final long startTick;
        // Count is updated after samples are successfully added to the map.
        private final ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values;

        private volatile int count;

        State(
                double alphaNanos,
                int size,
                long startTick,
                int count,
<span class="nc" id="L70">                ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values) {</span>
<span class="nc" id="L71">            this.alphaNanos = alphaNanos;</span>
<span class="nc" id="L72">            this.size = size;</span>
<span class="nc" id="L73">            this.startTick = startTick;</span>
<span class="nc" id="L74">            this.values = values;</span>
<span class="nc" id="L75">            this.count = count;</span>
<span class="nc" id="L76">        }</span>

        private void update(long value, long timestampNanos) {
<span class="nc" id="L79">            double itemWeight = weight(timestampNanos - startTick);</span>
<span class="nc" id="L80">            double priority = itemWeight / ThreadLocalRandom.current().nextDouble();</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">            boolean mapIsFull = count &gt;= size;</span>
<span class="nc bnc" id="L82" title="All 4 branches missed.">            if (!mapIsFull || values.firstKey() &lt; priority) {</span>
<span class="nc" id="L83">                addSample(priority, value, itemWeight, mapIsFull);</span>
            }
<span class="nc" id="L85">        }</span>

        private void addSample(double priority, long value, double itemWeight, boolean bypassIncrement) {
<span class="nc bnc" id="L88" title="All 4 branches missed.">            if (values.putIfAbsent(priority, new WeightedSample(value, itemWeight)) == null</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">                    &amp;&amp; (bypassIncrement || countUpdater.incrementAndGet(this) &gt; size)) {</span>
<span class="nc" id="L90">                values.pollFirstEntry();</span>
            }
<span class="nc" id="L92">        }</span>

        /* &quot;A common feature of the above techniques—indeed, the key technique that
         * allows us to track the decayed weights efficiently—is that they maintain
         * counts and other quantities based on g(ti − L), and only scale by g(t − L)
         * at query time. But while g(ti −L)/g(t−L) is guaranteed to lie between zero
         * and one, the intermediate values of g(ti − L) could become very large. For
         * polynomial functions, these values should not grow too large, and should be
         * effectively represented in practice by floating point values without loss of
         * precision. For exponential functions, these values could grow quite large as
         * new values of (ti − L) become large, and potentially exceed the capacity of
         * common floating point types. However, since the values stored by the
         * algorithms are linear combinations of g values (scaled sums), they can be
         * rescaled relative to a new landmark. That is, by the analysis of exponential
         * decay in Section III-A, the choice of L does not affect the final result. We
         * can therefore multiply each value based on L by a factor of exp(−α(L′ − L)),
         * and obtain the correct value as if we had instead computed relative to a new
         * landmark L′ (and then use this new L′ at query time). This can be done with
         * a linear pass over whatever data structure is being used.&quot;
         */
        State rescale(long newTick) {
<span class="nc" id="L113">            long durationNanos = newTick - startTick;</span>
<span class="nc" id="L114">            double scalingFactor = Math.exp(-alphaNanos * durationNanos);</span>
<span class="nc" id="L115">            int newCount = 0;</span>
<span class="nc" id="L116">            ConcurrentSkipListMap&lt;Double, WeightedSample&gt; newValues = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (Double.compare(scalingFactor, 0) != 0) {</span>
<span class="nc" id="L118">                RescalingConsumer consumer = new RescalingConsumer(scalingFactor, newValues);</span>
<span class="nc" id="L119">                values.forEach(consumer);</span>
                // make sure the counter is in sync with the number of stored samples.
<span class="nc" id="L121">                newCount = consumer.count;</span>
            }
            // It's possible that more values were added while the map was scanned, those with the
            // minimum priorities are removed.
<span class="nc bnc" id="L125" title="All 2 branches missed.">            while (newCount &gt; size) {</span>
<span class="nc" id="L126">                Objects.requireNonNull(newValues.pollFirstEntry(), &quot;Expected an entry&quot;);</span>
<span class="nc" id="L127">                newCount--;</span>
            }
<span class="nc" id="L129">            return new State(alphaNanos, size, newTick, newCount, newValues);</span>
        }

        private double weight(long durationNanos) {
<span class="nc" id="L133">            return Math.exp(alphaNanos * durationNanos);</span>
        }
    }

    private static final class RescalingConsumer implements BiConsumer&lt;Double, WeightedSample&gt; {
        private final double scalingFactor;
        private final ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values;
        private int count;

<span class="nc" id="L142">        RescalingConsumer(double scalingFactor, ConcurrentSkipListMap&lt;Double, WeightedSample&gt; values) {</span>
<span class="nc" id="L143">            this.scalingFactor = scalingFactor;</span>
<span class="nc" id="L144">            this.values = values;</span>
<span class="nc" id="L145">        }</span>

        @Override
        public void accept(Double priority, WeightedSample sample) {
<span class="nc" id="L149">            double newWeight = sample.weight * scalingFactor;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (Double.compare(newWeight, 0) == 0) {</span>
<span class="nc" id="L151">                return;</span>
            }
<span class="nc" id="L153">            WeightedSample newSample = new WeightedSample(sample.value, newWeight);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (values.put(priority * scalingFactor, newSample) == null) {</span>
<span class="nc" id="L155">                count++;</span>
            }
<span class="nc" id="L157">        }</span>
    }

<span class="nc" id="L160">    private LockFreeExponentiallyDecayingReservoir(int size, double alpha, Duration rescaleThreshold, Clock clock) {</span>
        // Scale alpha to nanoseconds
<span class="nc" id="L162">        double alphaNanos = alpha * SECONDS_PER_NANO;</span>
<span class="nc" id="L163">        this.size = size;</span>
<span class="nc" id="L164">        this.clock = clock;</span>
<span class="nc" id="L165">        this.rescaleThresholdNanos = rescaleThreshold.toNanos();</span>
<span class="nc" id="L166">        this.state = new State(alphaNanos, size, clock.getTick(), 0, new ConcurrentSkipListMap&lt;&gt;());</span>
<span class="nc" id="L167">    }</span>

    @Override
    public int size() {
<span class="nc" id="L171">        return Math.min(size, state.count);</span>
    }

    @Override
    public void update(long value) {
<span class="nc" id="L176">        long now = clock.getTick();</span>
<span class="nc" id="L177">        rescaleIfNeeded(now).update(value, now);</span>
<span class="nc" id="L178">    }</span>

    private State rescaleIfNeeded(long currentTick) {
        // This method is optimized for size so the check may be quickly inlined.
        // Rescaling occurs substantially less frequently than the check itself.
<span class="nc" id="L183">        State stateSnapshot = this.state;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (currentTick - stateSnapshot.startTick &gt;= rescaleThresholdNanos) {</span>
<span class="nc" id="L185">            return doRescale(currentTick, stateSnapshot);</span>
        }
<span class="nc" id="L187">        return stateSnapshot;</span>
    }

    private State doRescale(long currentTick, State stateSnapshot) {
<span class="nc" id="L191">        State newState = stateSnapshot.rescale(currentTick);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (stateUpdater.compareAndSet(this, stateSnapshot, newState)) {</span>
            // newState successfully installed
<span class="nc" id="L194">            return newState;</span>
        }
        // Otherwise another thread has won the race and we can return the result of a volatile read.
        // It's possible this has taken so long that another update is required, however that's unlikely
        // and no worse than the standard race between a rescale and update.
<span class="nc" id="L199">        return this.state;</span>
    }

    @Override
    public Snapshot getSnapshot() {
<span class="nc" id="L204">        State stateSnapshot = rescaleIfNeeded(clock.getTick());</span>
<span class="nc" id="L205">        return new WeightedSnapshot(stateSnapshot.values.values());</span>
    }

    public static Builder builder() {
<span class="nc" id="L209">        return new Builder();</span>
    }

    /**
     * By default this uses a size of 1028 elements, which offers a 99.9%
     * confidence level with a 5% margin of error assuming a normal distribution, and an alpha
     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.
     */
    public static final class Builder {
        private static final int DEFAULT_SIZE = 1028;
        private static final double DEFAULT_ALPHA = 0.015D;
<span class="nc" id="L220">        private static final Duration DEFAULT_RESCALE_THRESHOLD = Duration.ofHours(1);</span>

<span class="nc" id="L222">        private int size = DEFAULT_SIZE;</span>
<span class="nc" id="L223">        private double alpha = DEFAULT_ALPHA;</span>
<span class="nc" id="L224">        private Duration rescaleThreshold = DEFAULT_RESCALE_THRESHOLD;</span>
<span class="nc" id="L225">        private Clock clock = Clock.defaultClock();</span>

<span class="nc" id="L227">        private Builder() {}</span>

        /**
         * Maximum number of samples to keep in the reservoir. Once this number is reached older samples are
         * replaced (based on weight, with some amount of random jitter).
         */
        public Builder size(int value) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (value &lt;= 0) {</span>
<span class="nc" id="L235">                throw new IllegalArgumentException(</span>
                        &quot;LockFreeExponentiallyDecayingReservoir size must be positive: &quot; + value);
            }
<span class="nc" id="L238">            this.size = value;</span>
<span class="nc" id="L239">            return this;</span>
        }

        /**
         * Alpha is the exponential decay factor. Higher values bias results more heavily toward newer values.
         */
        public Builder alpha(double value) {
<span class="nc" id="L246">            this.alpha = value;</span>
<span class="nc" id="L247">            return this;</span>
        }

        /**
         * Interval at which this reservoir is rescaled.
         */
        public Builder rescaleThreshold(Duration value) {
<span class="nc" id="L254">            this.rescaleThreshold = Objects.requireNonNull(value, &quot;rescaleThreshold is required&quot;);</span>
<span class="nc" id="L255">            return this;</span>
        }

        /**
         * Clock instance used for decay.
         */
        public Builder clock(Clock value) {
<span class="nc" id="L262">            this.clock = Objects.requireNonNull(value, &quot;clock is required&quot;);</span>
<span class="nc" id="L263">            return this;</span>
        }

        public Reservoir build() {
<span class="nc" id="L267">            return new LockFreeExponentiallyDecayingReservoir(size, alpha, rescaleThreshold, clock);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>